// MIT License
// 
// Copyright (c) 2025 Alexander John Brown
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
// File Generated By Build Script
//

// Expanded from src/uci.c
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>

// Expanded from include/bot.h

#ifndef BOT_H
#define BOT_H

#ifndef __USE_POSIX199309
#define __USE_POSIX199309
#endif

#include <time.h>
#include <pthread.h>
#include <stdatomic.h>
#include <stdint.h>

// Expanded from include/chess.h
#ifndef CHESS_H
#define CHESS_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stddef.h>
#include <stdint.h>

#define RANK_SIZE 16
#define FILE_SIZE 16
#define LEFT_BORDER 0
#define TOP_BORDER 0
#define MOVE_PRIORITY_MAX 0xFFF

#define MAXSCORE ((centipawn_t)(INT16_MAX))
#define MINSCORE ((centipawn_t)(-INT16_MAX))

#define PAWN_SCORE   ((centipawn_t)(100))
#define KNIGHT_SCORE ((centipawn_t)(320))
#define BISHOP_SCORE ((centipawn_t)(330))
#define ROOK_SCORE   ((centipawn_t)(500))
#define QUEEN_SCORE  ((centipawn_t)(900))
#define KING_SCORE   ((centipawn_t)(14400))
#define CHECKMATE_SCORE ((centipawn_t)(-16000))
#define DRAW_SCORE ((centipawn_t)(0))

#define SQUARE_FROM_RANKFILE(file, rank) \
  ((rank) + TOP_BORDER) * FILE_SIZE + LEFT_BORDER + (file)

#define FOR_EACH_PIECE(PIECE_LIST, PIECE_TYPE, IDENTIFIER)                     \
  for (uint8_t index = 0, IDENTIFIER = (PIECE_LIST)->PIECE_TYPE##_list[index]; \
       index < (PIECE_LIST)->PIECE_TYPE##_count;                               \
       index++, IDENTIFIER = (PIECE_LIST)->PIECE_TYPE##_list[index])

// coordinates stored in 0x88 format
// upper nibble represents the rank
// lower nibble represents the file
// bit packing 0b0rrr0fff
// bits marked r are the rank, bits marked f are the file
// allows easy off the board checks
// https://www.chessprogramming.org/0x88
typedef uint8_t sq0x88_t;

// cordinates stored in 0..63 format
typedef uint8_t sq8x8_t;

// 0 indexed rank
typedef uint8_t rank07_t;

// 0 indexed file
typedef uint8_t file07_t;

// difference between two 0x88 coordinates
// is unique for all directions and distances unlike for 8x8 coordinates
typedef uint8_t diff0x88_t;

// https://www.chessprogramming.org/Butterfly_Boards
typedef uint16_t butterfly_index_t;

typedef int16_t centipawn_t;

// chess piece stored with disjoint piece flags
// https://www.chessprogramming.org/Pieces#Disjoint_Piece_Flags
// specific flag values derived from
// https://pure.uvt.nl/ws/files/1098572/Proefschrift_Fritz_Reul_170609.pdf
typedef uint8_t piece_t;

typedef uint8_t colour_t;

typedef enum {
  EMPTY = 0x00,
  PAWN = 0x01,
  KNIGHT = 0x02,
  BISHOP = 0x04,
  ROOK = 0x08,
  KING = 0x10,
  WHITE = 0x20,
  BLACK = 0x40,
  BORDER = 0x80,

  QUEEN = BISHOP | ROOK,

  PIECE_MASK = PAWN | KNIGHT | BISHOP | ROOK | QUEEN | KING,
  COLOUR_MASK = WHITE | BLACK,

  WHITE_PAWN = WHITE | PAWN,
  WHITE_KNIGHT = WHITE | KNIGHT,
  WHITE_BISHOP = WHITE | BISHOP,
  WHITE_ROOK = WHITE | ROOK,
  WHITE_QUEEN = WHITE | QUEEN,
  WHITE_KING = WHITE | KING,

  BLACK_PAWN = BLACK | PAWN,
  BLACK_KNIGHT = BLACK | KNIGHT,
  BLACK_BISHOP = BLACK | BISHOP,
  BLACK_ROOK = BLACK | ROOK,
  BLACK_QUEEN = BLACK | QUEEN,
  BLACK_KING = BLACK | KING,

} piece_encoding_t;

typedef enum {
  WHITE_QUEEN_SIDE = 0x8,
  WHITE_KING_SIDE = 0x4,
  BLACK_QUEEN_SIDE = 0x2,
  BLACK_KING_SIDE = 0x1,
  WHITE_BOTH_SIDES = WHITE_QUEEN_SIDE | WHITE_KING_SIDE,
  BLACK_BOTH_SIDES = BLACK_QUEEN_SIDE | BLACK_KING_SIDE,
  ALL_RIGHTS = WHITE_BOTH_SIDES | BLACK_BOTH_SIDES,
  NO_RIGHTS = 0,
} castle_rights_t;

// move flags
typedef enum {
  PROMOTION = 0x8,
  CAPTURE = 0x4,
  SPECIAL1 = 0x2,
  SPECIAL0 = 0x1,
  QUIET_MOVE = 0x0,

  DOUBLE_PAWN_PUSH = SPECIAL0,
  KING_CASTLE = SPECIAL1,
  QUEEN_CASTLE = SPECIAL0 | SPECIAL1,
  ENPASSENT = CAPTURE | SPECIAL0,
  KNIGHT_PROMOTE_TO = 0,
  BISHOP_PROMOTE_TO = SPECIAL0,
  ROOK_PROMOTE_TO = SPECIAL1,
  QUEEN_PROMOTE_TO = SPECIAL0 | SPECIAL1,
  KNIGHT_PROMOTION = PROMOTION | KNIGHT_PROMOTE_TO,
  BISHOP_PROMOTION = PROMOTION | BISHOP_PROMOTE_TO,
  ROOK_PROMOTION = PROMOTION | ROOK_PROMOTE_TO,
  QUEEN_PROMOTION = PROMOTION | QUEEN_PROMOTE_TO,
  KNIGHT_CAPTURE_PROMOTION = PROMOTION | CAPTURE | KNIGHT_PROMOTE_TO,
  BISHOP_CAPTURE_PROMOTION = PROMOTION | CAPTURE | BISHOP_PROMOTE_TO,
  ROOK_CAPTURE_PROMOTION = PROMOTION | CAPTURE | ROOK_PROMOTE_TO,
  QUEEN_CAPTURE_PROMOTION = PROMOTION | CAPTURE | QUEEN_PROMOTE_TO,

} move_flags_t;

enum {
  MAX_PAWNS = 8,
  MAX_KNIGHTS = 2 + 8,
  MAX_BISHOPS = 1 + 4,
  MAX_ROOKS = 2 + 8,
  MAX_QUEENS = 1 + 8,
};

enum {
  A1 = SQUARE_FROM_RANKFILE(0, 0),
  A2 = SQUARE_FROM_RANKFILE(0, 1),
  A3 = SQUARE_FROM_RANKFILE(0, 2),
  A4 = SQUARE_FROM_RANKFILE(0, 3),
  A5 = SQUARE_FROM_RANKFILE(0, 4),
  A6 = SQUARE_FROM_RANKFILE(0, 5),
  A7 = SQUARE_FROM_RANKFILE(0, 6),
  A8 = SQUARE_FROM_RANKFILE(0, 7),
  B1 = SQUARE_FROM_RANKFILE(1, 0),
  B2 = SQUARE_FROM_RANKFILE(1, 1),
  B3 = SQUARE_FROM_RANKFILE(1, 2),
  B4 = SQUARE_FROM_RANKFILE(1, 3),
  B5 = SQUARE_FROM_RANKFILE(1, 4),
  B6 = SQUARE_FROM_RANKFILE(1, 5),
  B7 = SQUARE_FROM_RANKFILE(1, 6),
  B8 = SQUARE_FROM_RANKFILE(1, 7),
  C1 = SQUARE_FROM_RANKFILE(2, 0),
  C2 = SQUARE_FROM_RANKFILE(2, 1),
  C3 = SQUARE_FROM_RANKFILE(2, 2),
  C4 = SQUARE_FROM_RANKFILE(2, 3),
  C5 = SQUARE_FROM_RANKFILE(2, 4),
  C6 = SQUARE_FROM_RANKFILE(2, 5),
  C7 = SQUARE_FROM_RANKFILE(2, 6),
  C8 = SQUARE_FROM_RANKFILE(2, 7),
  D1 = SQUARE_FROM_RANKFILE(3, 0),
  D2 = SQUARE_FROM_RANKFILE(3, 1),
  D3 = SQUARE_FROM_RANKFILE(3, 2),
  D4 = SQUARE_FROM_RANKFILE(3, 3),
  D5 = SQUARE_FROM_RANKFILE(3, 4),
  D6 = SQUARE_FROM_RANKFILE(3, 5),
  D7 = SQUARE_FROM_RANKFILE(3, 6),
  D8 = SQUARE_FROM_RANKFILE(3, 7),
  E1 = SQUARE_FROM_RANKFILE(4, 0),
  E2 = SQUARE_FROM_RANKFILE(4, 1),
  E3 = SQUARE_FROM_RANKFILE(4, 2),
  E4 = SQUARE_FROM_RANKFILE(4, 3),
  E5 = SQUARE_FROM_RANKFILE(4, 4),
  E6 = SQUARE_FROM_RANKFILE(4, 5),
  E7 = SQUARE_FROM_RANKFILE(4, 6),
  E8 = SQUARE_FROM_RANKFILE(4, 7),
  F1 = SQUARE_FROM_RANKFILE(5, 0),
  F2 = SQUARE_FROM_RANKFILE(5, 1),
  F3 = SQUARE_FROM_RANKFILE(5, 2),
  F4 = SQUARE_FROM_RANKFILE(5, 3),
  F5 = SQUARE_FROM_RANKFILE(5, 4),
  F6 = SQUARE_FROM_RANKFILE(5, 5),
  F7 = SQUARE_FROM_RANKFILE(5, 6),
  F8 = SQUARE_FROM_RANKFILE(5, 7),
  G1 = SQUARE_FROM_RANKFILE(6, 0),
  G2 = SQUARE_FROM_RANKFILE(6, 1),
  G3 = SQUARE_FROM_RANKFILE(6, 2),
  G4 = SQUARE_FROM_RANKFILE(6, 3),
  G5 = SQUARE_FROM_RANKFILE(6, 4),
  G6 = SQUARE_FROM_RANKFILE(6, 5),
  G7 = SQUARE_FROM_RANKFILE(6, 6),
  G8 = SQUARE_FROM_RANKFILE(6, 7),
  H1 = SQUARE_FROM_RANKFILE(7, 0),
  H2 = SQUARE_FROM_RANKFILE(7, 1),
  H3 = SQUARE_FROM_RANKFILE(7, 2),
  H4 = SQUARE_FROM_RANKFILE(7, 3),
  H5 = SQUARE_FROM_RANKFILE(7, 4),
  H6 = SQUARE_FROM_RANKFILE(7, 5),
  H7 = SQUARE_FROM_RANKFILE(7, 6),
  H8 = SQUARE_FROM_RANKFILE(7, 7),
};
// piece lists
// https://www.chessprogramming.org/Piece-Lists
// uses seperate lists for light and dark squared bishops
typedef struct {
  sq0x88_t king_square;
  sq0x88_t pawn_list[MAX_PAWNS];
  sq0x88_t knight_list[MAX_KNIGHTS];
  sq0x88_t light_bishop_list[MAX_BISHOPS];
  sq0x88_t dark_bishop_list[MAX_BISHOPS];
  sq0x88_t rook_list[MAX_ROOKS];
  sq0x88_t queen_list[MAX_QUEENS];
  uint8_t pawn_count, knight_count, light_bishop_count, dark_bishop_count,
      rook_count, queen_count;
  uint8_t indices_list[64];
} piece_list_t;


typedef struct move_t {
  sq0x88_t from, to;
  uint16_t priority_and_flags;
} move_t;

typedef uint16_t compact_move_t;

typedef uint64_t zobrist_t;

typedef struct ply_stack_item_t {
  move_t move;
  sq0x88_t enpassent;
  int half_move_clock;
  castle_rights_t rights;
  piece_t captured;
  sq0x88_t check_square;
  int n_checks;
  int discovered_check;
  zobrist_t zobrist;
  size_t last_irreversible;
} ply_stack_item_t;

typedef struct {
  // piece data
  piece_t
      board[RANK_SIZE * FILE_SIZE];  // board stored as 0x88 board with borders
  piece_list_t white_pieces, black_pieces;  // detailed piece lists

  // other board state info
  sq0x88_t enpassent_target;
  int ply_counter, half_move_clock;
  int black_to_move;
  castle_rights_t castle_rights;

  // running zobrist hash
  zobrist_t zobrist;

  // ply stack for unmake move and 3-fold repetition
  ply_stack_item_t* ply_stack;
  int ply_stack_capacity;
  int ply_of_last_irreversible_move;

  // check data from incremental check updates
  sq0x88_t check_square;
  int n_checks;
  int discovered_check;

  // data swapped each ply
  colour_t friendly_colour, enemy_colour;  // for relative colour comparisons
  sq0x88_t up_increment,
      down_increment;  // for pawn pushes and piece square tables
  piece_list_t *friendly_pieces, *enemy_pieces;  // for move and attack gen

} chess_state_t;

static const move_t null_move = {0, 0, 0};

// move_t interface functions

static inline sq8x8_t get_from(move_t move) { return move.from; }

static inline sq8x8_t get_to(move_t move) { return move.to; }

static inline move_flags_t get_flags(move_t move) {
  return (move_flags_t)(move.priority_and_flags & 0xF);
}

static inline int is_capture(move_t move) { return get_flags(move) & CAPTURE; }

static inline int is_enpassent(move_t move) {
  return get_flags(move) == ENPASSENT;
}

static inline int is_double_pawn_push(move_t move) {
  return get_flags(move) == DOUBLE_PAWN_PUSH;
}

static inline int is_queen_castle(move_t move) {
  return get_flags(move) == QUEEN_CASTLE;
}

static inline int is_king_castle(move_t move) {
  return get_flags(move) == KING_CASTLE;
}

static inline int is_promotion(move_t move) {
  return get_flags(move) & PROMOTION;
}

static inline piece_t get_promotes_to(move_t move) {
  switch (get_flags(move) & 3) {
    case KNIGHT_PROMOTE_TO:
      return KNIGHT;
    case BISHOP_PROMOTE_TO:
      return BISHOP;
    case ROOK_PROMOTE_TO:
      return ROOK;
    case QUEEN_PROMOTE_TO:
      return QUEEN;
    default:
      return EMPTY;
  }
}

static inline uint16_t get_priority(move_t move) {
  return (move.priority_and_flags & 0xFFF0) >> 4;
}

static inline move_t set_priority(move_t move, uint16_t prio) {
  move.priority_and_flags =
      ((prio << 4) & 0xFFF0) | (move.priority_and_flags & 0x000F);
  return move;
}

static inline int is_null_move(move_t move) { return move.from == move.to; }

// move constructor
static inline move_t move(sq8x8_t from, sq8x8_t to, int flags) {
#ifdef __cplusplus
  return move_t{from, to, (uint16_t)(flags & 0xF)};
#else
  return (move_t){from, to, (uint16_t)(flags & 0xF)};
#endif
}

// board interface

static inline piece_t piece(const chess_state_t* chess_state, sq0x88_t square) {
  return chess_state->board[square];
}

static inline int piece_is_white(const chess_state_t* chess_state,
                                 sq0x88_t square) {
  return chess_state->board[square] & WHITE;
}

static inline int piece_is_black(const chess_state_t* chess_state,
                                 sq0x88_t square) {
  return chess_state->board[square] & BLACK;
}

static inline int piece_is_friendly(const chess_state_t* chess_state,
                                    sq0x88_t square) {
  return chess_state->board[square] & chess_state->friendly_colour;
}

static inline int piece_is_enemy(const chess_state_t* chess_state,
                                 sq0x88_t square) {
  return chess_state->board[square] & chess_state->enemy_colour;
}

static inline int piece_is_empty(const chess_state_t* chess_state,
                                 sq0x88_t square) {
  return chess_state->board[square] == EMPTY;
}

static inline sq0x88_t enpassent_target(const chess_state_t* chess_state) {
  return chess_state->enpassent_target;
}

static inline int is_white_to_move(const chess_state_t* chess_state) {
  return !chess_state->black_to_move;
}

static inline int is_black_to_move(const chess_state_t* chess_state) {
  return chess_state->black_to_move;
}

// off the board checks

static inline uint8_t off_the_board(sq0x88_t sq0x88) {
  return sq0x88 & (uint8_t)0x88;
}

static inline rank07_t backrank(colour_t colour) {
  switch (colour & COLOUR_MASK) {
    case WHITE:
      return 7;
    case BLACK:
      return 0;
    default:
      return 0;
  }
}

// coordinate conversion funcitons

// convert from 0x88 representation to board index
static inline sq8x8_t sq0x88_to_sq8x8(sq0x88_t sq0x88) {
  return (sq0x88 + (sq0x88 & 7)) >> 1;
}
// convert from board index to 0x88 representation
static inline sq0x88_t sq8x8_to_sq0x88(sq8x8_t sq8x8) {
  return sq8x8 + (sq8x8 & ~7);
}

static inline rank07_t sq8x8_to_rank07(sq8x8_t sq8x8) { return sq8x8 >> 3; }

static inline file07_t sq8x8_to_file07(sq8x8_t sq8x8) { return sq8x8 & 7; }

static inline rank07_t sq0x88_to_rank07(sq0x88_t sq0x88) { return sq0x88 >> 4; }

static inline file07_t sq0x88_to_file07(sq0x88_t sq0x88) { return sq0x88 & 7; }

static inline sq0x88_t rankfile_to_sq0x88(rank07_t rank07, file07_t file07) {
  return (rank07 << 4) + file07;
}

static inline sq8x8_t rankfile_to_sq8x8(rank07_t rank07, file07_t file07) {
  return (rank07 << 3) + file07;
}

static inline diff0x88_t diff_0x88(sq0x88_t from, sq0x88_t to) {
  return (diff0x88_t)0x77 + from - to;
}

// square colour checks

static inline uint8_t is_light_square(sq0x88_t square) {
  return ((square & (sq0x88_t)1) ^ ((square >> 4) & (sq0x88_t)1));
}

static inline uint8_t is_dark_square(sq0x88_t square) {
  return !is_light_square(square);
}

static inline int compare_moves(move_t lhs, move_t rhs) {
  return lhs.from == rhs.from && lhs.to == rhs.to &&
         get_flags(lhs) == get_flags(rhs);
}

static inline compact_move_t compress_move(move_t move) {
  return sq0x88_to_sq8x8(move.from) | (sq0x88_to_sq8x8(move.to) << 6) |
         ((move.priority_and_flags & 0xF) << 12);
}

static inline move_t uncompress_move(compact_move_t compact_move) {
  return move(sq8x8_to_sq0x88(compact_move), sq8x8_to_sq0x88(compact_move >> 6),
              compact_move >> 12);
}

static inline colour_t piece_colour(const chess_state_t* chess_state,
                                    sq0x88_t square) {
  return (piece(chess_state, square) & COLOUR_MASK);
}

static inline int piece_is_colour(const chess_state_t* chess_state,
                                  sq0x88_t square, colour_t colour) {
  return piece_colour(chess_state, square) == colour;
}

static inline colour_t opposite_colour(colour_t colour) {
  switch (colour & COLOUR_MASK) {
    case BLACK:
      return WHITE;
    case WHITE:
      return BLACK;
    default:
      return EMPTY;
  }
}

static inline sq0x88_t pawn_push_increment(colour_t colour) {
  return (colour & WHITE) ? (sq0x88_t)(A2 - A1) : (sq0x88_t)(A1 - A2);
}

static inline const piece_list_t* get_piece_list(
    const chess_state_t* chess_state, colour_t colour) {
  return (colour & WHITE) ? &chess_state->white_pieces
                          : &chess_state->black_pieces;
}

static inline int is_promoting(sq0x88_t from, colour_t colour) {
  return (sq0x88_to_rank07(from) == 1 && colour == BLACK) ||
         (sq0x88_to_rank07(from) == 6 && colour == WHITE);
}

static inline int pawn_can_double_push(sq0x88_t from, colour_t colour) {
  return (sq0x88_to_rank07(from) == 6 && colour == BLACK) ||
         (sq0x88_to_rank07(from) == 1 && colour == WHITE);
}

static inline centipawn_t value_of(piece_t piece) {
  switch (piece & PIECE_MASK) {
    case PAWN:
      return PAWN_SCORE;
    case KNIGHT:
      return KNIGHT_SCORE;
    case BISHOP:
      return BISHOP_SCORE;
    case ROOK:
      return ROOK_SCORE;
    case QUEEN:
      return QUEEN_SCORE;
    case KING:
      return KING_SCORE;
    default:
      return 0;
  }
}

sq0x88_t queen_increment(sq0x88_t from, sq0x88_t to);

sq0x88_t rook_increment(sq0x88_t from, sq0x88_t to);

sq0x88_t bishop_increment(sq0x88_t from, sq0x88_t to);

sq0x88_t knight_increment(sq0x88_t from, sq0x88_t to);

sq0x88_t king_increment(sq0x88_t from, sq0x88_t to);

// returns true if the players piece at square can be pseudo captured
int is_under_attack(const chess_state_t* chess_state, sq0x88_t square,
                    piece_t player);

// returns true if there is atleast one piece threatening the king
int is_check(const chess_state_t* chess_state);

// returns true if two (or more) pieces are threatening the king
int is_double_check(const chess_state_t* chess_state);

// returns true if the king is checked through a discovered attack
int is_discover_check(const chess_state_t* chess_state);

// returns true if the position is check after the move is made
int is_check_after_move(const chess_state_t* chess_state, move_t move);

// returns the square of the checking piece, if there is no checking piece it
// will return 0x88. if the position is double check it has undefined value and
// should not be used.
sq0x88_t checking_square(const chess_state_t* chess_state);

int can_capture_enpassent(const chess_state_t*, sq0x88_t from, colour_t colour);

int can_castle_king_side(const chess_state_t* chess_state, colour_t colour);

int can_castle_queen_side(const chess_state_t* chess_state, colour_t colour);

// returns index of first non white space character
long skip_whitespace_internal(const char* buffer);

// writes a square in format file rank, e.g. a1, h4, c8
long write_square(char* buffer, long buffer_size, sq0x88_t square);

// reads a square in format file rank, e.g. a1, h4, c8
long read_square(const char* buffer, long buffer_size, sq0x88_t* square);

// writes the letter code for a piece, e.g. P, K, N
long write_piece(char* buffer, long buffer_size, piece_t piece);

// reads the letter code for a piece, e.g. P, K, N
long read_piece(const char* buffer, long buffer_size, piece_t* piece);

// write to buffer in algebraic notation
// e.g. e8=Q or Nb3
long write_algebraic_notation(char* buffer, long buffer_size,
                              chess_state_t* chess_state, move_t move);

// read from buffer a move in algebraic notation
// e.g. e8=Q or Nb3
long read_algebraic_notation(const char* buffer, long buffer_size,
                             const chess_state_t* chess_state, move_t* move);

// write to buffer in long algebraic notation
// e.g. e7e8Q or e1b3
long write_long_algebraic_notation(char* buffer, long buffer_size, move_t move);
// read from buffer a move in long algebraic notation
// e.g. e7e8Q or e1b3
long read_long_algebraic_notation(const char* buffer, long buffer_size,
                                  const chess_state_t* chess_state,
                                  move_t* move);

// writes a sequence of space seperated moves in algebraic notation.
long write_movetext(char* buffer, long buffer_size,
                    const chess_state_t* chess_state,
                    const char* start_position);

// when debugging the chess_state struct may be in an invalid state after an
// illegal move, using write_movetext to traverse the plystack may be dangerous
// so instead use this version. Since write_long_algebraic_notation does not
// depend on the chess_state, all moves can be written out in a traversal
// without cloning the game and making moves.
long write_movetext_debug(char* buffer, long buffer_size,
                          const chess_state_t* chess_state);

// writes the pgn out to a buffer
// event, site, date, round, names, and fen are all optional parameters, if set
// to NULL they will be left empty in pgn.
long write_pgn(char* buffer, long buffer_size, const chess_state_t* chess_state,
               const char* event, const char* site, const char* date,
               const char* round, const char* white_name,
               const char* black_name, const char* fen);

// loads default chess starting position
void load_start_position(chess_state_t* chess_state);

// release resources
void release_position(chess_state_t* chess_state);

// clones the position
void copy_position(chess_state_t* chess_state,
                   const chess_state_t* state_to_copy);

// clears the position to an empty board
void clear_position(chess_state_t* chess_state);

// load game from fen string
long load_position(chess_state_t* chess_state, const char* fen_string);

// write fen string of current position
long save_position(const chess_state_t* chess_state, char* buffer,
                   long buffer_size);

// updates the games state
void make_move(chess_state_t* chess_state, move_t move);

// restores the position to the previous state
void unmake_move(chess_state_t* chess_state);

// assumes the resulting position is not in check.
// returns true if the move doesn't move an absolutely pinned piece
int is_legal(const chess_state_t* chess_state, move_t move);

// assumes the resulting is not in check.
// returns true if the move doesn't move an absolutely pinned piece
// performs test for player 'colour'
// this allows legality tests on moves for the opposing player
int is_legal_internal(const chess_state_t* chess_state, move_t move,
                      colour_t colour);

// checks move rules, does not check if piece is pinned, must be combined with
// is_legal for full validation
int is_pseudo_legal(const chess_state_t* chess_state, move_t move);

int is_legal_internal(const chess_state_t* chess_state, move_t move,
                      colour_t colour);

// incremental move generation
// all move gen is divided into 3 categories
// generate promotions
// generate captures (excluding capture promotions)
// generate quiet moves
// generate moves performs all 3 of these together
// each produces psuedo legal moves that MUST be checked for legality before
// being played each has a legal variant that performs this for the user
// although this is not required and incremental legality checking is supported
// and even encouraged

// generates psuedo legal moves, is_legal test should be performed before move
// is played.
size_t generate_moves(const chess_state_t* chess_state, move_t* moves,
                      colour_t colour);

// generates psuedo legal capturing moves, is_legal test should be performed
// before move is played.
size_t generate_captures(const chess_state_t* chess_state, move_t* moves,
                         colour_t colour);

// generates psuedo legal quiet moves, is_legal test should be performed before
// move is played.
size_t generate_quiets(const chess_state_t* chess_state, move_t* moves,
                       colour_t colour);

// generates psuedo legal promoting moves, is_legal test should be performed
// before move is played.
size_t generate_promotions(const chess_state_t* chess_state, move_t* moves,
                           colour_t colour);

size_t generate_legal_moves(const chess_state_t* chess_state, move_t* moves,
                            colour_t colour);
size_t generate_legal_captures(const chess_state_t* chess_state, move_t* moves,
                               colour_t colour);
size_t generate_legal_quiets(const chess_state_t* chess_state, move_t* moves,
                             colour_t colour);
size_t generate_legal_promotions(const chess_state_t* chess_state,
                                 move_t* moves, colour_t colour);


size_t generate_moves_nocheck_internal(const chess_state_t* chess_state,
                                       move_t* moves, colour_t colour);

size_t generate_moves_check_internal(const chess_state_t* chess_state,
                                     move_t* moves, colour_t colour);

// zobrist own inverse function to incrementally update the running zobrist hash
// of the current position
zobrist_t zobrist_flip_turn(zobrist_t zobrist);

// zobrist own inverse function to incrementally update the running zobrist hash
// of the current position
zobrist_t zobrist_flip_piece(zobrist_t zobrist, piece_t piece, sq0x88_t square);
zobrist_t zobrist_move_piece(zobrist_t zobrist, piece_t piece,
                             sq0x88_t from, sq0x88_t to);
// checks if the position is drawn by any of draw by repetition, draw by
// insufficient material, or draw by 50 move rule
int is_draw(const chess_state_t* chess_state);

// checks for 3 fold repetition
int is_draw_by_repetition(const chess_state_t* chess_state);

// checks for draw from insufficient material
int is_draw_by_insufficient_material(const chess_state_t* chess_state);

// checks for draw by 50 move rule
int is_draw_by_50_move_rule(const chess_state_t* chess_state);

// is_checkmate and is_stalemate should be avoided for non leaf nodes to avoid
// duplication of move generation
int is_checkmate(const chess_state_t* chess_state);

// is_checkmate and is_stalemate should be avoided for non leaf nodes to avoid
// duplication of move generation
int is_stalemate(const chess_state_t* chess_state);

enum gameover_state {
  ONGOING = 0,
  CHECKMATE = 1,
  STALEMATE = -1,
  DRAW_BY_REPETITION = -2,
  DRAW_BY_50_MOVE_RULE = -3,
  DRAW_BY_INSUFFICIENT_MATERIAL = -4
};

// 0 for ongoing, 1 for checkmate, < 0 for draw/stalemate
enum gameover_state is_gameover(const chess_state_t* chess_state);

// WHITE if white wins, BLACK if black wins, EMPTY if draw or game ongoing, use
// is_gameover to check if game is ongoing
colour_t get_winner(const chess_state_t* chess_state);

// casts a ray starting at square and iterating in the opposite direction to inc
sq0x88_t backwards_ray_cast(const chess_state_t* chess_state, sq0x88_t square,
                            sq0x88_t inc);

// casts a ray starting at square and iterating in the same direction as inc
sq0x88_t forwards_ray_cast(const chess_state_t* chess_state, sq0x88_t from,
                           sq0x88_t inc);

void trace_ply_stack(const chess_state_t* chess_state);

// for internal use only
// initializes check when loading a position
void init_check(chess_state_t* chess_state);

// for internal use only
// pushes data onto ply stack so it can be retrieved when unmaking moves
void push_ply_stack(chess_state_t* chess_state, move_t move);

// for internal use only
// updates the pieces on the board
void update_board(chess_state_t* chess_state, move_t move);

// for internal use only
// updates the castle rights after a move
void update_rights(chess_state_t* chess_state, move_t move);

// for internal use only
// updates enpassent target
// if move is a double pawn push sets enpassent target to the square the pawn skipped
void update_enpassent_target(chess_state_t* chess_state, move_t move);

// for internal use only
// updates half move clock
// sets it to 0 if move is irreversible
// increments by 1 if it is reversible
void update_half_move_clock(chess_state_t* chess_state, move_t move);

// for internal use only
// swaps whose turn it is
void update_turn(chess_state_t* chess_state);

// for internal use only
// does incremental check to see if the position is check
void update_check(chess_state_t* chess_state, move_t move);

// for internal use only
// removes a piece from a square
// should NEVER be used on an empty square (will assert fail)
void remove_piece(chess_state_t* chess_state, sq0x88_t target);

// for internal use only
// places a piece on a square
// should NEVER be used to place an empty square (will assert fail)
void place_piece(chess_state_t* chess_state, sq0x88_t target, piece_t piece);

// for internal use only
// moves a piece from `from` to `to`
// should NEVER be used to move an empty square, and should never move to a non-empty square.
// to capture a piece, first remove the piece, then move the capturing piece onto the square.
// may assert fail if used improperly (i.e. moving an empty square)
void move_piece(chess_state_t* chess_state, sq0x88_t from, sq0x88_t to);

size_t knight_moves(const chess_state_t* chess_state, move_t* moves,
                    size_t move_count, sq0x88_t from, colour_t colour);

size_t king_moves(const chess_state_t* chess_state, move_t* moves,
                  size_t move_count, sq0x88_t king_square, colour_t colour);

size_t castling_moves(const chess_state_t* chess_state, move_t* moves,
                      size_t move_count, sq0x88_t king_square, colour_t colour);

// flags should either be QUIET_MOVE or CAPTURE, add_promotion_moves will handle
// the promotion flags
size_t add_promotion_moves(move_t* moves, size_t move_count, sq0x88_t from,
                           sq0x88_t to, int flags);

size_t pawn_moves(const chess_state_t* chess_state, move_t* moves,
                  size_t move_count, sq0x88_t from, colour_t colour);

size_t sliding_moves(const chess_state_t* chess_state, move_t* moves,
                     size_t move_count, sq0x88_t from, colour_t colour,
                     const sq0x88_t* increments, int increments_count);

size_t sliding_quiets(const chess_state_t* chess_state, move_t* moves,
                      size_t move_count, sq0x88_t from,
                      const sq0x88_t* increments, int increments_count);

size_t sliding_captures(const chess_state_t* chess_state, move_t* moves,
                        size_t move_count, sq0x88_t from, colour_t colour,
                        const sq0x88_t* increments, int increments_count);

#ifdef __cplusplus
}
#endif

#endif

#define BUTTERFLY_BOARD_SIZE (64 * 64)
#define MAX_KILLER_MOVES 2

struct match_state_t;
struct bot_settings_t;
struct bot_term_cond_t;
struct bot_t;
struct worker_t;

enum tt_entry_type { 
  TT_EMPTY = 0, // slot is empty
  TT_EXACT,     // slot is a pv node
  TT_UPPER,     // slot failed low
  TT_LOWER,     // slot failed high
};

// bitpacked data for transposition table entry
// layout
// 0..2 type
// 2..16 unused
// 16..24 age
// 24..32 depth
// 32..48 score
// 48..64 best move
typedef uint64_t entry_t;

// key value paired stored using xor validation
// key value is key ^ entry so to check if key matches do key == entry.key ^
// entry.entry this guarantees correctness as if two threads write the key and
// entry for a node simultaneously it will be invalidated
// https://www.chessprogramming.org/Shared_Hash_Table#Xor
typedef struct key_entry_pair_t {
  zobrist_t key;
  uint64_t entry;
} key_entry_pair_t;

// lockless shared transposition table
// https://www.chessprogramming.org/Shared_Hash_Table#Xor
typedef struct table_t {
  volatile struct key_entry_pair_t* items;
  uint64_t capacity;
} table_t;

typedef struct bot_settings_t {
  int debug;   // debug flag
  int Hash;    // size of transposition table in MB
  int Ponder;  // whether pondering is enabled
  // other settings ...
} bot_settings_t;

typedef struct bot_term_cond_t {
  long time_limit_ms;
  long node_limit_nds;
  long depth_limit_ply;
  long mate_in_ply;
} bot_term_cond_t;

typedef struct match_state_t {
  // time control info
  size_t wtime;
  size_t btime;
  size_t winc;
  size_t binc;
} match_state_t;

typedef struct bot_t {
  int n_threads;  // number of threads to use
  struct worker_t** workers;

  struct bot_settings_t settings;

  enum {
    SEARCHMODE_INACTIVE,
    SEARCHMODE_REGULAR,
    SEARCHMODE_PONDER
  } search_mode;  // inactive=0, regular=1, ponder=2

  // state
  atomic_bool running, abort;
  struct timespec start_time;
  atomic_intmax_t duration_ms;
  atomic_intmax_t nodes_searched;
  atomic_intmax_t depth_searched;

  // termination conditions
  struct bot_term_cond_t stop_cond;

  // match info
  struct match_state_t match_info;

  // position
  chess_state_t root_position;

  // shared structures
  table_t transpostion_table;
} bot_t;

//
// basic single threaded worker type
typedef struct worker_t {
  // bot api should only look at this bit
  int id;
  pthread_t handle;
  int terminated;
  bot_t* bot;

  chess_state_t position;
  int move_count;
  centipawn_t scores[256];
  move_t moves[256];
  compact_move_t killer_moves[64][MAX_KILLER_MOVES];
  int root_ply;
  int16_t history_heuristic[BUTTERFLY_BOARD_SIZE];
  int16_t butterfly_heuristic[BUTTERFLY_BOARD_SIZE];

} worker_t;

/**
 * Struct to store the search state
 */
typedef struct search_t {
  chess_state_t position;

  // root node info
  int root_move_count;
  centipawn_t root_move_scores[256];
  move_t root_moves[256];

  table_t * transpo_table;
  // table_t * pv_table; // use a seperate table just for pv nodes?!?
  compact_move_t killer_move_table[64][MAX_KILLER_MOVES];

  int root_ply;
} search_t;

/*
typedef struct {
  move_t move, refutation;
  score_cp_t score;
  int depth_searched;
} root_move_t;
*/

// initialises the bot with settings,
// if settings is null it uses default settings
int bot_init(bot_t* bot, bot_settings_t* settings);

// loads the fen string into position
int bot_load_fen(bot_t* bot, const char* postext);

// loads a move into position
int bot_load_move(bot_t* bot, const char* movetext);

// starts the bot
int bot_start(bot_t* bot);

// converts the ponder search into regular searching
int bot_ponder_hit(bot_t* bot);

// cancels the search
int bot_stop(bot_t* bot);

// releases bot resources
int bot_release(bot_t* bot);

// called when the bot completes a search or the search is cancelled
void bot_on_stop(bot_t* bot);

// checks if bot is still running
int bot_is_running(bot_t* bot);

// waits until the bot finishes running
int bot_wait(bot_t* bot);

// begins search
void* worker_start(void*);

// checks if this thread is the main thread, i.e. the first thread in the thread list
int is_main_thread(const worker_t*);

// checks if termination condition is met or if the bots abort flag is set
int stop(worker_t*);

// logs info to gui
void log_info();

// returns correctly formatted bestmove to gui
void bestmove(move_t bestmove, move_t ponder);

// add killer move to killer move list
void add_killer_move(compact_move_t* killer_moves, move_t move);

// gets the static exchange evaluation
// returns positive if it is a winning exchange
// returns negative if it is a losing exchange
// returns zero if it is an even exchange
centipawn_t static_exchange_evaluation(const chess_state_t* chess_state,
  move_t move);

// gets the index in the butterfly board for move
static inline int butterfly_index(move_t move) {
  int from = sq0x88_to_sq8x8(move.from);
  int to = sq0x88_to_sq8x8(move.to);
  return (to<<6)+from;
}

static inline void inc_butteryfly_board(int16_t* board, move_t move) {
  board[butterfly_index(move)]++;
}

static inline int16_t get_butteryfly_board(int16_t* board, move_t move) {
  return board[butterfly_index(move)];
}

void reset_butterfly_board(int16_t* board);

enum move_order_state {
  PRIORITY_PV_MOVE         = 0xA00,
  PRIORITY_WINNING_CAPTURE = 0x800,
  PRIORITY_NEUTRAL_CAPTURE = 0x600,
  PRIORITY_KILLER_MOVES    = 0x400,
  PRIORITY_LOSING_CAPTURE  = 0x200,
  PRIORITY_QUIET_MOVE      = 0x000,
};

// stores move ordering and moves
typedef struct move_list_t {
  move_t moves[256];
  size_t move_count;
  move_t hash_move;
  compact_move_t* killer_moves;
  int16_t* bh, *hh;
  enum move_order_state state;
} move_list_t;

// initializes move list
void init_move_list(const chess_state_t* position, move_list_t* move_list, move_t hash_move, compact_move_t* killer_moves, int16_t*,int16_t*);

// gets next move from move list the move ordering rules
// returns null_move when move list is exhausted
move_t next_move(const chess_state_t* position, move_list_t* move_list);

// gets next capture from move list the move ordering rules
// returns null_move when all captures from move list are exhausted
move_t next_capture(const chess_state_t* position, move_list_t* move_list);

move_t entry_best_move(entry_t entry);

centipawn_t entry_score(entry_t entry);

enum tt_entry_type entry_type(entry_t entry);

int entry_depth(entry_t entry);

int entry_age(entry_t entry);

entry_t make_entry(enum tt_entry_type type, move_t best_move, centipawn_t score,
                   int depth, int age);

void tt_init(table_t* table, uint64_t capacity);

void tt_free(table_t* table);

entry_t tt_get(table_t* table, zobrist_t key);

// stores using always replace policy
void tt_store(table_t* table, zobrist_t key, enum tt_entry_type type,
              move_t best_move, centipawn_t score, int depth, int age);

// stores using depth prefered policy
void tt_store_depth_prefered(table_t* table, zobrist_t key,
                             enum tt_entry_type type, move_t best_move,
                             centipawn_t score, int depth, int age);

// only stores node if it is an exact node
void tt_store_pv(table_t* table, zobrist_t key, enum tt_entry_type type,
                 move_t best_move, centipawn_t score, int depth, int age);

// searches root position to fixed depth
int      rootSearch(worker_t* worker, centipawn_t alpha, centipawn_t beta, int depth);

// implements pv search and nega-max
centipawn_t abSearch(worker_t* worker, centipawn_t alpha, centipawn_t beta, int depth);

// implements quiescence search with nega-max with check extensions
centipawn_t  qSearch(worker_t* worker, centipawn_t alpha, centipawn_t beta, int depth);

centipawn_t piece_value(sq0x88_t, piece_t piece);

centipawn_t material_score(const chess_state_t*);

// statically analyses position
centipawn_t eval(const chess_state_t* position);

// checks if position is either a threefold repetition or is a repetition within the search
int is_repetition(const chess_state_t* position, int ply_of_root);

static const centipawn_t king_square_table[64] = {
     20,  50,   0, -10, -25,  50,  60,  20,
     10,  20, -50, -75, -50,  20,  20,  10,
     10, -20, -75,-100,-100, -50, -50,  10,
    -20, -50,-110,-110,-110,-110,-110, -20,
   -125,-125,-125,-125,-125,-125,-125,-125,
   -150,-150,-150,-150,-150,-150,-150,-150, 
   -175,-175,-175,-175,-175,-175,-175,-175,
   -200,-200,-200,-200,-200,-200,-200,-200,
};
static const centipawn_t queen_square_table[64] = {
      0,   5,  10,  10,   5,   5,   5,   0,
      0,   5,  20,  15,  10,   5,  10,   0,
      0,  20,   0,   0,   0,  10,   0,   0,
     15,   0,   0,   0,   0,   0,   5,   0,
      0,   0,   0,   0,   0,   0,   0,   5,
      0,   0,   0,   0,   0,   0,   0,   0, 
      0,   0,   0,   0,   0,   0,   0,   0,
    -10, -10, -10, -10, -10, -10, -10, -10,
};
static const centipawn_t rook_square_table[64] = {
      0,  10,  20,  30,  30,  20,  10,   0,
     10,   0,   0,  20,  20,   0,   0,  10,
     20,   0,   0,   0,   0,   0,   0,  20,
     30,   0,   0,   0,   0,   0,   0,  30,
     30,   0,   0,   0,   0,   0,   0,  30,
     20,   0,   0,   0,   0,   0,   0,  20, 
     50,  50,  50,  50,  50,  50,  50,  50,
      0,  10,  20,  30,  30,  20,  10,   0,
};
static const centipawn_t bishop_square_table[64] = {
     10,  -5,  -5,  -5,  -5,  -5,  -5,  10,
      5,  20,  10,  20,  20,  10,  20,   0,
     10,   0,   5,  20,  20,   5,   0,  10,
      0,   0,  20,  10,  10,  20,   0,   0,
      0,   0,   0,  10,  10,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0, 
      0,   0,   0,   0,   0,   0,   0,   0,
    -10,   0,   0,   0,   0,   0,   0, -10,
};
static const centipawn_t knight_square_table[64] = { // 10 for each plmove
   -100, -10, -10, -10, -10, -10, -10,-100,
    -40,   0,  10,  10,  10,  10,   0, -40,
    -20,   0,  20,  20,  20,  20,   0, -20,
    -10,   0,  20,  40,  40,  20,   0, -10,
    -10,   0,  20,  40,  40,  20,   0, -10,
    -20,   0,  20,  20,  20,  20,   0, -20, 
    -60, -40, -10, -10, -10, -10, -40, -60,
   -100, -80, -50, -50, -50, -50, -80,-100,
};

static const centipawn_t pawn_square_table[64] = {
      0,   0,   0,   0,   0,   0,   0,   0,
     50,  50, -10, -10, -10,  15,  35,  50,
     10,  10,   5,   5,   5,  10,  10,  10,
     20, -10,  20,  20,  20,   5, -10,  20,
     30,  10,  30,  30,  30,  15,  10,  30,
     75,  75,  75,  75,  75,  75,  75,  75, 
    200, 200, 200, 200, 200, 200, 200, 200,
      0,   0,   0,   0,   0,   0,   0,   0,
    };

#endif

#define AUTHOR "Alex B"
#define BOT_NAME "PieceMeal"
#define BOT_VERSION "1.2.0"

#define UNIMPLEMENTED fprintf(stderr, "unimplemented\n")
#define INVALIDARG(CMD) fprintf(stderr, "\"%.*s\" is not a valid argument for command \"%s\"\n", (arglen), (arg), (CMD))
#define MISSINGARG(CMD, ARG) fprintf(stderr, "command \"%s\" is missing required argument \"%s\"\n", (CMD), (ARG))
#define LOGERROR(msg, ...) fprintf(stderr, msg "\n", ##__VA_ARGS__)
#define FATALERROR(msg, ...) {LOGERROR(msg, ##__VA_ARGS__); exit(-1);}
#define TELLGUI(msg, ...) { fprintf(stdout, msg "\n", ##__VA_ARGS__); fflush(stdout); }

#define BUFFER_SIZE 256

bot_t bot;
const char * startpos = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
int pos, arglen;
char * arg;
char buffer[BUFFER_SIZE];

void quit() {
  bot_release(&bot);
  exit(0);
}

int uci_is_whitespace(char c) {
  return c == ' ' || c == '\t';
}

int uci_is_newline(char c) {
  return c == '\n';
}

int uci_is_delim(char c) {
  return c == 0 || c == ' ' || c == '\t' || c == '\n';
}

int uci_strcmp(const char* lhs, const char* rhs) {
  while (!uci_is_delim(*lhs) && !uci_is_delim(*rhs)) {
    if (*lhs != *rhs) return 0;
    lhs++;
    rhs++;
  }
  return uci_is_delim(*lhs) && uci_is_delim(*rhs);
}

void uci_read_from_stdin(int keep) {
  if (keep == 0 && buffer[0]) {
    LOGERROR("argument too big, discarding first %d bytes", BUFFER_SIZE);
    keep = pos;
  }
  pos = pos - keep;
  memmove(buffer, &buffer[keep], pos);
  if (fgets(&buffer[pos], BUFFER_SIZE - pos, stdin) == NULL) {
    if (feof(stdin)) {
      LOGERROR("bot reached eof");
      quit();
    }
    FATALERROR("bot failed to read from stdin: %s", strerror(errno));
  }
}

void uci_next_arg() {

  do {

    while (buffer[pos] && uci_is_whitespace(buffer[pos])) {
      pos++;
    }

    if (buffer[pos] == 0) {
      uci_read_from_stdin(pos);
      continue;
    }
    break;
  } while (1);

  if (uci_is_newline(buffer[pos])) {
    pos++;
    arg = NULL;
    return;
  }

  int arg_start = pos;

  do {
    while (buffer[pos] && !uci_is_whitespace(buffer[pos]) && !uci_is_newline(buffer[pos])) {
        pos++;
    }
    if (buffer[pos] == 0) {
      uci_read_from_stdin(arg_start);
      arg_start = 0;
      continue;
    }
    
    break;
  } while (1);

  arglen = pos - arg_start;

  // printf("token %.*s\n", arglen, &buffer[arg_start]);
  arg = &buffer[arg_start];
}

void uci_handler() {
  if (bot_init(&bot, NULL)) {
    FATALERROR("failed to initialise bot " BOT_NAME " " BOT_VERSION);
  }
  TELLGUI("id name " BOT_NAME " " BOT_VERSION);
  TELLGUI("id author " AUTHOR);
  TELLGUI("uciok");
  uci_next_arg();
}

void debug_handler() {
  uci_next_arg();
  if (arg && uci_strcmp(arg, "on")) {
    bot.settings.debug = 1;
  } else if (arg && uci_strcmp(arg, "off")) {
    bot.settings.debug = 0;
  } else {
    MISSINGARG("debug", "on/off");
  }
}

void isready_handler() {
  TELLGUI("readyok");
  uci_next_arg();
}

void ucinewgame_handler() {
  bot_load_fen(&bot, startpos);
  uci_next_arg();
}

void position_handler() {
  uci_next_arg();
  if (arg && uci_strcmp(arg, "startpos")) {
    bot_load_fen(&bot, startpos);
    uci_next_arg();
  } else if (arg && uci_strcmp(arg, "fen")) {
    char FEN[BUFFER_SIZE];
    int fpos = 0;
    uci_next_arg();
    while (arg && !uci_strcmp(arg, "moves")) {
      if (fpos + arglen + 2 >= BUFFER_SIZE) {
        LOGERROR("fen too long");
        break;
      }
      memcpy(&FEN[fpos], arg, arglen);
      fpos += arglen;
      FEN[fpos++] = ' ';
      uci_next_arg();
    }
    FEN[fpos] = 0;
    int out = bot_load_fen(&bot, FEN);
    if (out < 0) {
      LOGERROR("invalid fen \"%s\"", arg);
      return;
    }
  } else {
    MISSINGARG("position", "fen/startpos");
  }

  if (arg && uci_strcmp(arg, "moves")) {
    uci_next_arg();

    while (arg) {
      if (bot_load_move(&bot, arg) < 0) {
        LOGERROR("invalid move in movetext \"%s\"", arg);
        return;
      }
      uci_next_arg();
    }
  }
}

void go_handler() {
  bot.search_mode = SEARCHMODE_REGULAR;
  bot.stop_cond = (bot_term_cond_t){0, 0, 0, 0};
  uci_next_arg();
  while (arg) {
    if (uci_strcmp(arg, "searchmoves")) {
      UNIMPLEMENTED;
    } else if (uci_strcmp(arg, "ponder")) {
      if (bot.settings.Ponder != 1) {
        LOGERROR("cannot ponder, ponder mode is disabled");
        return; // do not ponder
      } else {
        bot.search_mode = SEARCHMODE_PONDER;
      }
    } else if (uci_strcmp(arg, "wtime")) {
      
      uci_next_arg();
      if (arg) {
      bot.match_info.wtime = atoll(arg);
      } else {
        MISSINGARG("wtime", "<time ms>");
      }
    } else if (uci_strcmp(arg, "btime")) {
      uci_next_arg();
      if (arg) {
        bot.match_info.btime = atoll(arg);
      } else {
        MISSINGARG("btime", "<time ms>");
      }
    } else if (uci_strcmp(arg, "winc")) {
      uci_next_arg();
      if (arg) {
        bot.match_info.winc = atoll(arg);
      } else {
        MISSINGARG("winc", "<inc ms>");
      }
    } else if (uci_strcmp(arg, "binc")) {
      uci_next_arg();
      if (arg) {
        bot.match_info.binc = atoll(arg);
      } else {
        MISSINGARG("binc", "<inc ms>");
      }
    } else if (uci_strcmp(arg, "movestogo")) {
      UNIMPLEMENTED;
      uci_next_arg();
    } else if (uci_strcmp(arg, "depth")) {
      uci_next_arg();
      if (arg) {
        bot.stop_cond.depth_limit_ply = atoll(arg);
      }
    } else if (uci_strcmp(arg, "nodes")) {
      uci_next_arg();
      if (arg) {
        bot.stop_cond.node_limit_nds = atoll(arg);
      }
    } else if (uci_strcmp(arg, "mate")) {
      uci_next_arg();
      if (arg) {
        bot.stop_cond.mate_in_ply = atoll(arg);
      }
    } else if (uci_strcmp(arg, "movetime")) {
      uci_next_arg();
      if (arg) {
        bot.stop_cond.time_limit_ms = atoll(arg);
      }
    } else if (uci_strcmp(arg, "infinite")) {
      bot.stop_cond.depth_limit_ply = 0;
      bot.stop_cond.node_limit_nds = 0;
      bot.stop_cond.time_limit_ms = 0;
      bot.stop_cond.mate_in_ply = 0;
    } else {
      INVALIDARG("go");
    }
    uci_next_arg();
  }

  bot_start(&bot);
}

void stop_handler() {
  bot_stop(&bot);
  bot_wait(&bot);
  uci_next_arg();
}

void ponderhit_handler() {
  bot_ponder_hit(&bot);
  uci_next_arg();
}

void handle_command() {
  const char * cmd;
  do {

    uci_next_arg();

    if (arg == NULL) {
      break;
    }

    if (uci_strcmp(arg, "uci")) {
      cmd = "uci";
      uci_handler();

    } else if (uci_strcmp(arg, "debug")) {
      cmd = "debug";
      debug_handler();

    } else if (uci_strcmp(arg, "isready")) {
      cmd = "isready";
      isready_handler();

    } else if (uci_strcmp(arg, "setoption")) {
      cmd = "setoption";
      UNIMPLEMENTED;

    } else if (uci_strcmp(arg, "register")) {
      cmd = "register";
      UNIMPLEMENTED;

    } else if (uci_strcmp(arg, "ucinewgame")) {
      cmd = "ucinewgame";
      ucinewgame_handler();

    } else if (uci_strcmp(arg, "position")) {
      cmd = "position";
      position_handler();

    } else if (uci_strcmp(arg, "go")) {
      cmd = "go";
      go_handler();
      
    } else if (uci_strcmp(arg, "stop")) {
      cmd = "stop";
      stop_handler();

    } else if (uci_strcmp(arg, "ponderhit")) {
      cmd = "ponderhit";
      ponderhit_handler();

    } else if (uci_strcmp(arg, "quit")) {
      quit();

    } else {
      LOGERROR("\"%.*s\" is not a valid command", arglen, arg);
      continue;
    }
    
    break;
  } while (1); // loop until we find a valid command

  while (arg) {
    INVALIDARG(cmd);
    uci_next_arg();
  }

}

int main(void) {
  for (;;) {
    handle_command(buffer);
  }
}
// Expanded from src/chess/threats.c

#include <stdio.h>


int discover_check_after_move(const chess_state_t* chess_state,
                              sq0x88_t king_square,
                              sq0x88_t revealing_piece_from,
                              sq0x88_t revealing_piece_to) {
  sq0x88_t inc = queen_increment(revealing_piece_from, king_square);
  if (!inc) return 0;
  // check if piece is still in the same "line" with the King as before
  if (inc == queen_increment(revealing_piece_to, king_square)) return 0;

  // if another piece is between this piece and the king it is not a reveal
  if (forwards_ray_cast(chess_state, revealing_piece_from, inc) != king_square)
    return 0;

  // get the piece that is revealed (if one exists)
  piece_t revealed_square =
      backwards_ray_cast(chess_state, revealing_piece_from, inc);

  if (off_the_board(revealed_square) ||
      piece_is_enemy(chess_state, revealed_square))
    return 0;

  piece_t revealed_piece = piece(chess_state, revealed_square);
  // check piece can move to the king square
  if (!((revealed_piece & BISHOP) &&
        bishop_increment(revealed_square, king_square)) &&
      !((revealed_piece & ROOK) &&
        rook_increment(revealed_square, king_square))) {
    return 0;
  }
  return 1;
}

int discover_enpassent_check_after_move(const chess_state_t* chess_state,
                                        sq0x88_t king_square,
                                        sq0x88_t pawn_move_from,
                                        sq0x88_t pawn_move_to,
                                        sq0x88_t captured_pawn) {
  sq0x88_t inc = queen_increment(captured_pawn, king_square);
  if (!inc) return 0;
  // check if piece is still in the same "line" with the King as before
  if (inc == queen_increment(pawn_move_to, king_square)) return 0;

  // if another piece is between this piece and the king it is not a reveal
  piece_t square = forwards_ray_cast(chess_state, captured_pawn, inc);
  if (square == pawn_move_from) {
    square = forwards_ray_cast(chess_state, square, inc);
  }
  if (square != king_square)
    return 0;

  // get the piece that is revealed (if one exists)
  piece_t revealed_square = backwards_ray_cast(chess_state, captured_pawn, inc);

  if (revealed_square == pawn_move_from) {
    revealed_square = backwards_ray_cast(chess_state, revealed_square, inc);
  }

  if (off_the_board(revealed_square) ||
      piece_is_enemy(chess_state, revealed_square))
    return 0;

  piece_t revealed_piece = piece(chess_state, revealed_square);
  // check piece can move to the king square
  if (!((revealed_piece & BISHOP) &&
        bishop_increment(revealed_square, king_square)) &&
      !((revealed_piece & ROOK) &&
        rook_increment(revealed_square, king_square))) {
    return 0;
  }
  return 1;
}

// based on update check
// we only check the pieces moved in the previous turn to see if they can attack the opposing king.
// we must also check for discovered attacks that were blocked by the moved piece.
// castle moves must also check if the moved rook can attack the opposing king.
// there is additionally an edge case with enpassent reveal attacks that must be considered seperately.
int is_check_after_move(const chess_state_t* chess_state, move_t move) {
  sq0x88_t king_square;
  if (chess_state->black_to_move) {
    king_square = chess_state->white_pieces.king_square;
  } else {
    king_square = chess_state->black_pieces.king_square;
  }
  piece_t moved_piece;
  if (is_promotion(move)) {
    moved_piece = get_promotes_to(move);
  } else {
    moved_piece = piece(chess_state, move.from);
  }
  sq0x88_t to = get_to(move);
  sq0x88_t from = get_from(move);

  if (is_queen_castle(move)) {
    sq0x88_t rook_moved_to = to + (sq0x88_t)1;
    sq0x88_t inc = rook_increment(rook_moved_to, king_square);
    if (inc &&
        forwards_ray_cast(chess_state, rook_moved_to, inc) == king_square) {
      return 1;
    }
  }
  if (is_king_castle(move)) {
    sq0x88_t rook_moved_to = to - (sq0x88_t)1;
    sq0x88_t inc = rook_increment(rook_moved_to, king_square);
    if (inc &&
        forwards_ray_cast(chess_state, rook_moved_to, inc) == king_square) {
      return 1;
    }
  }
  // if moved piece has bishop flag set, i.e. it is a bishop or queen
  if (moved_piece &
      BISHOP) {  // <- maybe should be an API for this to abstract it
    sq0x88_t inc = bishop_increment(to, king_square);
    if (inc) {
      sq0x88_t square = forwards_ray_cast(chess_state, to, inc);
      if (square == king_square) {
        return 1;
      }
      if (square == from &&
          forwards_ray_cast(chess_state, from, inc) == king_square) {
        return 1;
      }
    }
  }
  // if moved piece has rook flag set, i.e. it is a bishop or queen
  if (moved_piece & ROOK) {
    sq0x88_t inc = rook_increment(to, king_square);
    sq0x88_t square = forwards_ray_cast(chess_state, to, inc);
    if (square == king_square) {
      return 1;
    }
    if (square == from &&
        forwards_ray_cast(chess_state, from, inc) == king_square) {
      return 1;
    }
  }
  if ((moved_piece & KNIGHT) && knight_increment(to, king_square)) {
    return 1;
  }

  // pawn threats
  sq0x88_t pawn_inc = pawn_push_increment(chess_state->friendly_colour);
  if ((moved_piece & PAWN) && ((sq0x88_t)(to + pawn_inc + 1) == king_square ||
                               (sq0x88_t)(to + pawn_inc - 1) == king_square)) {
    return 1;
  }
  // consider reveals
  if (discover_check_after_move(chess_state, king_square, from, to)) {
    return 1;
  }

  if (is_enpassent(move) &&
      discover_enpassent_check_after_move(chess_state, king_square, from, to, to - pawn_inc)) {
    return 1;
  }

  return 0;
}

// check for reveal attacks
void update_discover_check(chess_state_t* chess_state, sq0x88_t king_square,
                           sq0x88_t revealing_piece_from,
                           sq0x88_t revealing_piece_to) {
  sq0x88_t inc = queen_increment(revealing_piece_from, king_square);
  if (!inc) return;
  // check if piece is still in the same "line" with the King as before
  if (inc == queen_increment(revealing_piece_to, king_square)) return;

  // if another piece is between this piece and the king it is not a reveal
  if (forwards_ray_cast(chess_state, revealing_piece_from, inc) != king_square)
    return;

  // get the piece that is revealed (if one exists)
  piece_t revealed_square =
      backwards_ray_cast(chess_state, revealing_piece_from, inc);

  if (off_the_board(revealed_square) ||
      piece_is_friendly(chess_state, revealed_square))
    return;

  piece_t revealed_piece = piece(chess_state, revealed_square);
  // check piece can move to the king square
  if (!((revealed_piece & BISHOP) &&
        bishop_increment(revealed_square, king_square)) &&
      !((revealed_piece & ROOK) &&
        rook_increment(revealed_square, king_square))) {
    return;
  }
  chess_state->check_square = revealed_square;
  chess_state->n_checks++;
  chess_state->discovered_check = 1;
}

// update check is an incremental check procedure
// we only check the pieces moved in the previous turn to see if they can attack the opposing king.
// we must also check for discovered attacks that were blocked by the moved piece.
// castle moves must also check if the moved rook can attack the opposing king.
// there is additionally an edge case with enpassent reveal attacks that must be considered seperately.
void update_check(chess_state_t* chess_state, move_t move) {
  sq0x88_t king_square;
  if (chess_state->black_to_move) {
    king_square = chess_state->black_pieces.king_square;
  } else {
    king_square = chess_state->white_pieces.king_square;
  }

  chess_state->check_square = 0x88;
  chess_state->n_checks = 0;
  chess_state->discovered_check = 0;

  piece_t moved_piece = piece(chess_state, move.to);
  sq0x88_t to = get_to(move);
  sq0x88_t from = get_from(move);

  if (is_queen_castle(move)) {
    sq0x88_t rook_moved_to = to + (sq0x88_t)1;
    sq0x88_t inc = rook_increment(rook_moved_to, king_square);
    if (inc &&
        forwards_ray_cast(chess_state, rook_moved_to, inc) == king_square) {
      chess_state->check_square = rook_moved_to;
      chess_state->n_checks++;
    }
  }
  if (is_king_castle(move)) {
    sq0x88_t rook_moved_to = to - (sq0x88_t)1;
    sq0x88_t inc = rook_increment(rook_moved_to, king_square);
    if (inc &&
        forwards_ray_cast(chess_state, rook_moved_to, inc) == king_square) {
      chess_state->check_square = rook_moved_to;
      chess_state->n_checks++;
    }
  }
  // if moved piece has bishop flag set, i.e. it is a bishop or queen
  if (moved_piece & BISHOP) {  // <- maybe should be an API for this to abstract it
    sq0x88_t inc = bishop_increment(to, king_square);
    if (inc && forwards_ray_cast(chess_state, to, inc) == king_square) {
      chess_state->check_square = to;
      chess_state->n_checks++;
    }
  }
  // if moved piece has rook flag set, i.e. it is a bishop or queen
  if (moved_piece & ROOK) {
    sq0x88_t inc = rook_increment(to, king_square);
    if (inc && forwards_ray_cast(chess_state, to, inc) == king_square) {
      chess_state->check_square = to;
      chess_state->n_checks++;
    }
  }
  if (moved_piece & KNIGHT) {
    sq0x88_t inc = knight_increment(to, king_square);
    if (inc) {
      chess_state->check_square = to;
      chess_state->n_checks++;
    }
  }

  // pawn threats
  sq0x88_t pawn_inc = chess_state->down_increment;
  if ((moved_piece & PAWN) && ((sq0x88_t)(to + pawn_inc + 1) == king_square ||
                               (sq0x88_t)(to + pawn_inc - 1) == king_square)) {
    chess_state->check_square = to;
    chess_state->n_checks++;
  }
  // consider reveals
  update_discover_check(chess_state, king_square, from, to);

  // enpassent reveals
  if (!chess_state->discovered_check && is_enpassent(move)) {
    update_discover_check(chess_state, king_square, to - pawn_inc, to);
  }

  if (is_double_check(chess_state) && !is_discover_check(chess_state)) {
    fprintf(stderr, "invalid double check!!!\n");
  }
}

// checks if the square can be attacked by colour
// this procedure checks `backwards` to see if there is any piece that can attack the square
// this is a slow procedure, but only needs to be used for is_legal checks for king moves
// may be worth removing and replacing with an incremental approach that keeps track of which squares each player to pseudo legal attack
int is_under_attack(const chess_state_t* chess_state, sq0x88_t square,
                    piece_t colour) {
  colour_t attacker = opposite_colour(colour);
  const piece_list_t* enemy_pieces = get_piece_list(chess_state, attacker);
  const piece_list_t* friendly_pieces = get_piece_list(chess_state, colour);
  sq0x88_t enemy_king_square = enemy_pieces->king_square;
  sq0x88_t king_square = friendly_pieces->king_square;

  // king moves
  if (king_increment(enemy_king_square, square)) return 1;

  // queen moves
  for (int p = 0; p < enemy_pieces->queen_count; p++) {
    sq0x88_t from = enemy_pieces->queen_list[p];
    sq0x88_t inc = queen_increment(from, square);
    if (inc == 0) continue;
    sq0x88_t next = backwards_ray_cast(chess_state, square, inc);
    if (next == from) return 1;
    if (next == king_square &&
        backwards_ray_cast(chess_state, next, inc) == from)
      return 1;
  }

  // rook moves
  for (int p = 0; p < enemy_pieces->rook_count; p++) {
    sq0x88_t from = enemy_pieces->rook_list[p];
    sq0x88_t inc = rook_increment(from, square);
    if (inc == 0) continue;
    sq0x88_t next = backwards_ray_cast(chess_state, square, inc);
    if (next == from) return 1;
    if (next == king_square &&
        backwards_ray_cast(chess_state, next, inc) == from)
      return 1;
  }

  if (is_light_square(square)) {
    // light bishop moves
    for (int p = 0; p < enemy_pieces->light_bishop_count; p++) {
      sq0x88_t from = enemy_pieces->light_bishop_list[p];
      sq0x88_t inc = bishop_increment(from, square);
      if (inc == 0) continue;
      sq0x88_t next = backwards_ray_cast(chess_state, square, inc);
      if (next == from) return 1;
      if (next == king_square &&
          backwards_ray_cast(chess_state, next, inc) == from)
        return 1;
    }
  } else {
    // dark bishop moves
    for (int p = 0; p < enemy_pieces->dark_bishop_count; p++) {
      sq0x88_t from = enemy_pieces->dark_bishop_list[p];
      sq0x88_t inc = bishop_increment(from, square);
      if (inc == 0) continue;
      sq0x88_t next = backwards_ray_cast(chess_state, square, inc);
      if (next == from) return 1;
      if (next == king_square &&
          backwards_ray_cast(chess_state, next, inc) == from)
        return 1;
    }
  }

  // knight moves
  for (int p = 0; p < enemy_pieces->knight_count; p++) {
    sq0x88_t from = enemy_pieces->knight_list[p];
    if (knight_increment(from, square)) return 1;
  }

  // pawn captures
  sq0x88_t inc = pawn_push_increment(attacker);
  sq0x88_t from;
  from = square - inc + (sq0x88_t)1;
  if (!off_the_board(from) && piece(chess_state, from) == (attacker | PAWN))
    return 1;
  from = square - inc - (sq0x88_t)1;
  if (!off_the_board(from) && piece(chess_state, from) == (attacker | PAWN))
    return 1;

  return 0;
}

void init_check(chess_state_t* chess_state) {
  piece_list_t* pl;
  piece_t opposing_player;
  sq0x88_t king_square;
  if (chess_state->black_to_move) {
    pl = &chess_state->white_pieces;
    opposing_player = WHITE;
    king_square = chess_state->black_pieces.king_square;
  } else {
    pl = &chess_state->black_pieces;
    opposing_player = BLACK;
    king_square = chess_state->white_pieces.king_square;
  }

  chess_state->check_square = 0x88;
  chess_state->discovered_check = 0;
  chess_state->n_checks = 0;

  // queen moves
  for (int p = 0; p < pl->queen_count; p++) {
    sq0x88_t from = pl->queen_list[p];
    sq0x88_t inc = queen_increment(from, king_square);
    if (inc && forwards_ray_cast(chess_state, from, inc) == king_square) {
      chess_state->check_square = from;
      chess_state->n_checks++;
    }
  }

  // rook moves
  for (int p = 0; p < pl->rook_count; p++) {
    sq0x88_t from = pl->rook_list[p];
    sq0x88_t inc = rook_increment(from, king_square);
    if (inc && forwards_ray_cast(chess_state, from, inc) == king_square) {
      chess_state->check_square = from;
      chess_state->n_checks++;
    }
  }

  if (is_light_square(king_square)) {
    // light bishop moves
    for (int p = 0; p < pl->light_bishop_count; p++) {
      sq0x88_t from = pl->light_bishop_list[p];
      sq0x88_t inc = bishop_increment(from, king_square);
      if (inc && forwards_ray_cast(chess_state, from, inc) == king_square) {
        chess_state->check_square = from;
        chess_state->n_checks++;
      }
    }
  } else {
    // dark bishop moves
    for (int p = 0; p < pl->dark_bishop_count; p++) {
      sq0x88_t from = pl->dark_bishop_list[p];
      sq0x88_t inc = bishop_increment(from, king_square);
      if (inc && forwards_ray_cast(chess_state, from, inc) == king_square) {
        chess_state->check_square = from;
        chess_state->n_checks++;
      }
    }
  }

  // knight moves
  for (int p = 0; p < pl->knight_count; p++) {
    sq0x88_t from = pl->knight_list[p];
    if (knight_increment(from, king_square)) {
      chess_state->check_square = from;
      chess_state->n_checks++;
    }
  }

  // pawn captures
  sq0x88_t inc = chess_state->down_increment;
  sq0x88_t from;
  from = king_square - inc + 1;
  if (!off_the_board(from) &&
      piece(chess_state, from) == (opposing_player | PAWN)) {
    chess_state->check_square = from;
    chess_state->n_checks++;
  }
  from = king_square - inc - 1;
  if (!off_the_board(from) &&
      piece(chess_state, from) == (opposing_player | PAWN)) {
    chess_state->check_square = from;
    chess_state->n_checks++;
  }
}

int is_check(const chess_state_t* chess_state) {
  return chess_state->n_checks > 0;
}

int is_double_check(const chess_state_t* chess_state) {
  return chess_state->n_checks > 1;
}

int is_discover_check(const chess_state_t* chess_state) {
  return chess_state->discovered_check;
}

sq0x88_t checking_square(const chess_state_t* chess_state) {
  return chess_state->check_square;
}
// Expanded from src/chess/zobrist.c
// Expanded from include/zobrist.h
#ifndef CHESS_ZOBRIST_TABLES_H
#define CHESS_ZOBRIST_TABLES_H


static const zobrist_t zobrist_black_to_move = 0xe0d0b548a1b99a23;

static const zobrist_t zobrist_table[12][64] = {
	{0x2dae09ad1339045b, 0x05e0fba6f0f47492, 0x72ab76087574f1ea, 0x9263b8a8b2bf912b, 0xbded81813ae7d9a9, 0x18f79b9be09ee66f, 0x65717d454f252620, 0x98591669ff36a5d6, 0xe85dd7491f89c66c, 0xadd841fc30d8e3e9, 0x66bfc8cf77408678, 0x23dd0e3f2e110fef, 0xfabd66e2f31267e9, 0x0d657551e158ac36, 0x3b4743673546ef16, 0x40363f6a924d2328, 0x6a47aa5ad2fcb97e, 0x8ffb23bbd9bac2bf, 0x0637992cbcc9e651, 0x5b85c45a2275d573, 0x63446f6e3695bc58, 0x3718bc885e2e9065, 0xd764301059f68c85, 0xd3947a953abbedf4, 0xcc040867b03047a7, 0xd3169dccf7ae78be, 0x63fdcd7c390701e6, 0x80aeb77394a4f221, 0x6afb82e11a44119a, 0x0b43f155e12397cf, 0x09b193fc7888ffcd, 0xb26bada081ae7bf4, 0x3f30cf6f0257f17d, 0x94a14741379258e2, 0x50ef6da2d92e2fc4, 0x641d32afbb26dccd, 0x70d95f9a61ab00c1, 0x656343fae8f86171, 0xb504095bca940a28, 0x33ee68b8f4c24a87, 0x9d4dd767c2beabca, 0x30c68832cf81df9b, 0xb2cfecd10938c86e, 0x82ea9ce5f7e9dd42, 0x59df4b5cca378e03, 0x507c0030b0ebeacd, 0x58ac0a0abde58af4, 0xdee20165f578c1e0, 0x72cf8add7288a01d, 0x12e24871eb32dfab, 0xd25fa061126a00ee, 0x4909acb85f69cd4a, 0x27620148264d9cf2, 0xa1e1047c111ede28, 0x7f085c98e1a188e1, 0x8022d6a951d9b920, 0x8f47e2659a92374a, 0x1427f66908bfe9d9, 0xac8cd900992f6400, 0xf3c81f9811d7b8c4, 0xf80b24256a65c5f1, 0xf4e9a4b60aecc45c, 0x9c6377fc741b6654, 0x3888732dc602c470, },
	{0x16f48eecc4f4bfc7, 0x10655d81af069c3a, 0xa52df405a42deb59, 0xd1e0a2817c871259, 0x73ce909d5a2e8f2f, 0x0f7f72ae04f3cae2, 0x3ccdb0259e56b09b, 0xa3d945cfc81d1258, 0xc1e38b7a865a6f32, 0xef797f38f746a9f6, 0x5f4b4c0442cf7e98, 0x7e0f9eb213e1f73a, 0xe71390447c149afa, 0x75db258388db9d5b, 0x7bf85e1a5681539c, 0x6b8ef51c24371683, 0x56649bbc05906304, 0xaf34c9e5ba4bab85, 0x2501cd56d528e75a, 0x1fb2f6b00070116e, 0xea6ce4968c07db64, 0x24c3511a1521e552, 0x2d094ae1a3746321, 0x0d38ae95c93616a2, 0x3099eeb5803c1021, 0xbf391732b8346bf8, 0xf3acdfd2a00b9718, 0x125bb264d3fe9dee, 0x6152f6a4392b7b96, 0xf50a29880b03aa03, 0x8ccacea5dd28a0d3, 0xd24d4d68121b8adb, 0x7fb5f1fbf73aabe8, 0x9a991d758257045f, 0xcc8bb48c85fe3cc7, 0x817077ef06200232, 0xaffc120a7b2f4023, 0xc0719e30a0f1d48f, 0x7d821d0fe7329781, 0x51be8d9b7fc8f352, 0x83f3ee6fbe85aaaf, 0xbd0281854ec759c4, 0x13ca47a439d486a9, 0x12599faef5e6225a, 0xae004ec816cdd719, 0xef7e5ed5a684b92b, 0x00c248b3cda22333, 0x8db9967d444c6e14, 0x2016ea23301d86a1, 0x460e9f3445fa083e, 0xe6845d670a52dd3d, 0xf4178f8d483afd72, 0x75475d1e3aeb8f9d, 0x80e14f0eada6a364, 0x0f0c3b672a67bef5, 0x440b45726e8e012e, 0x270f368fbe679fbf, 0x7bc37643af528dc0, 0x086a8ddef6e26325, 0x3936fcc782841d40, 0xb6f8d70d3ce557b5, 0xb6e8c3d5db35e111, 0x5e6075f7615fe02c, 0xf62d2884ae058065, },
	{0x7979fc2070344939, 0x21a7b37a92ba6bd9, 0x9ecf2f9294a4a30a, 0xb952974429307f2b, 0x4f5c1437a45068fa, 0x08e0d8e423c3ba87, 0x7b0dbd1e25bf8c9e, 0x7afbbf482c26eb7e, 0xaefdb15b8e93aa52, 0x5df5a4155030b02c, 0x01226963d8f99fe5, 0xa0a7758755b0aa72, 0xa666bc242001631a, 0xb9dbf234687ef3a8, 0x41d4b31b318229a6, 0x3ce71bfabec652cf, 0xad8e956a39476254, 0x15858dfc4f4e7c4c, 0x186dcfe956700d97, 0x5b7abc4534116daa, 0x66a5b5711de99c2a, 0x2d20333618115a1e, 0x1c9e1fd202472fdf, 0x333aee1fc1234fbf, 0x7cfd864ad3a37293, 0x19096cc41fb271b8, 0x87ea09ce431c8409, 0x3b9f43a8453a5214, 0x2395e1691872852b, 0x4afc1adb6f678ede, 0xcbbc3b5890cc25e8, 0xf595ca36ec964093, 0xf5a7d8d9f9964ada, 0x3e1b154b020497f7, 0x2cbb6ab7e4207ddc, 0x0d392f5da14f520f, 0xe377524011590007, 0xf67c880dcdd47efc, 0x92152de59578251f, 0xb84fbe28080065c2, 0xee9b6b43311b24f1, 0x3bf0c14e7e96ee3a, 0x5a5310bbb4360855, 0x2e61e89d87aff382, 0x3a6a0f3f382e5673, 0x0de31bed99aae7f5, 0xe3f806b1bdd75ee9, 0x5eb9cf531e784c30, 0xf84a4b71855599aa, 0x4aaf92865b0aea58, 0x83c7c07c74f512c9, 0x42053f43f1aaf0ad, 0x1a40ec54159e636a, 0xdfc0f38b8c8ffa25, 0xad9028203deb38a5, 0x98720a426942cd67, 0x49504fceea7a5196, 0x9938b7c0ff95f5da, 0x748ff3edd73abafe, 0x0ba7b4f660467bca, 0xe00cd9a97f509a6b, 0xdf3bda3521e9b197, 0x93078632e5e1e776, 0xe2c4840e233b8470, },
	{0x71fc4eb727d4903a, 0xa1c39c4156efee18, 0x90dac5199e5beeaf, 0x9625d0c4f586a891, 0x24250102c47ca230, 0x8d82543b47cf8456, 0xa068b3ee3ea0b28b, 0xa0bd47e34ce0fd04, 0xa5b85b3ae8226d7b, 0x255f945545661830, 0x881ee806aaa0fca0, 0x4ce93e16de58e992, 0x5603886ec1a63b35, 0x5103527891de79b8, 0x6ce1d8e5449ff399, 0x2fc2bae652a75bd1, 0xf6aedb4f1e466a06, 0x6af7b6b8773e2558, 0xfc301ba342c749a1, 0x71b079bfd33a5bdd, 0x9531ffd01e0cc31e, 0xbefde1ca95492f2f, 0x3b662531bb4839a6, 0x1f2cea34269cc7ea, 0x85aa23fd1478649b, 0x8bfe3bb5535069a3, 0x3fa864a4afab460e, 0xcd57925533b81a66, 0x5ff2695e22f7de76, 0x94ba33b0a2c467fa, 0x23923fb0d2b49e0a, 0x5355c66e83ff6526, 0x541389fdc69f014b, 0xcf0dd7ae32875a6d, 0x3684c3f5002ebc87, 0xb75bc75725d5cd65, 0x8a9cc2ddbf71a631, 0x81d434364f0f334f, 0x5cf8e495c31c2621, 0x798c2f8be8931953, 0xa24327049579a325, 0x6d4f61b212e89885, 0x9d151d1dac0ac7e7, 0xee1380404ef9a42d, 0xda39f7f284606d42, 0xb5517b0c6401bdf4, 0xb92869de742850ec, 0x489177d5a3d3c44e, 0xb2e034316e95068e, 0x5e69833ee33a7984, 0x7e61be5282809151, 0x240a07da5f800ea0, 0x84e408f32857bdf7, 0xdddeae9684082aec, 0x6743bb8b48f5a88c, 0xa5ee020cb9d8e679, 0x6f073038a97587a1, 0x340b48effbb66a1a, 0x5cff7c5d8837d523, 0xe4f5497671f1344f, 0x50dc3ab2a16c01fa, 0xc10b1602a6201baa, 0x78cf63ed7a3d8bfb, 0x1e061318cbb55f46, },
	{0xd0a5b491b7470baf, 0xe87c9571dca420be, 0x251587bfec2ccb86, 0x141d742dfd848ab2, 0x5b01b7d3b7dbad28, 0x768de72f1a6ce4ab, 0x1aba6fea955f18b1, 0x79479e1743793341, 0x932d788df2dcab70, 0x7eed166771637e7d, 0x3b34e99489adddc4, 0x6ad4cde9404a175e, 0xf8b8a82f7111a78a, 0x680258379a8891d9, 0x53e8f546f49ff263, 0x880f55a89ef6f98e, 0xc6afcf1bb5a5a141, 0x9efdcae734cb4377, 0x5de1a10d75a52835, 0x6fc6d408f3bec6cb, 0x157dd32693d13de8, 0x23aef115eadedc3b, 0x5d78b08c2e062eae, 0x269cae323f733d1b, 0xf9c9988f4cb2b78b, 0xc07be39af77c7374, 0xccca32f3e07ff691, 0xbae49bd0f83364e0, 0xc54e45aea739721b, 0x528fa58881439b69, 0x82cf79fb8077682c, 0x6855861db959bae2, 0xc98e8d28ca65b55a, 0xc58dfe4c19cc4471, 0x099c70a85e96dd80, 0xf2b7d64524961ea8, 0x02dae2d5c239cd22, 0x0d9138b45e056e57, 0x45547c887199741b, 0x174ce1c73121a86b, 0xc649d6e7f60d3a4b, 0xae53ad518c84776e, 0xc3ec0d63f27da86b, 0xea843dbf34764741, 0xc977782d5ab7d0cf, 0xef23540aae1dd0f1, 0xc7e942879efd3fbf, 0xa30f99849dec9ed4, 0xa4cb1bdf1d4bcf11, 0x7e7999247eb6364a, 0xb7d945611aaa3441, 0x712139cb4f414ffa, 0xa461b011861ad48e, 0x660062769fe1dd93, 0x717d89ae25f82edf, 0x2f445f3b00696bf6, 0xf0ad06503e22403f, 0x73d95dc7dbde271a, 0xf2f281ccda3e1acb, 0x7caf6396bd6f0ea9, 0x065ec1dd9775042a, 0xf201f366b0fbde28, 0xf2db89b52b9ff397, 0x863da6c02a0f9ccb, },
	{0xda45176cc04ef34a, 0x9dc2ee53c358ca53, 0xb45e932622a75fef, 0x6fe3438471e1927e, 0xf71942fb3eba193c, 0x8cf35345db3de228, 0x323bc942104d3558, 0x5d670315fcb1af29, 0x1b4c1298622ca34e, 0x705979ed489c5a84, 0xf55b8ca99960feda, 0x1c79e3e800a4bf2f, 0x9644d326dc70c935, 0xe573270376209500, 0x0dc57cd81a3a35f6, 0x67cee2e24be518e2, 0x30b022b14e91b18a, 0x944f1a594bf49ea3, 0x879ccc52dbafb837, 0x60e9a1f0fd0aed3e, 0xa89999cc25212b8c, 0xba4c62a460b7c478, 0xf9954d6229b1c29e, 0x476b68ca35cac991, 0xca45f446d0b2711a, 0xcba4128e48e8b8bd, 0x8dfa1b0393fe6ce0, 0x244b499a9058c9b9, 0xb65a04c01360f3d7, 0xb2167877519c4354, 0xa9f9717694f71b6d, 0x2217a7b049b870f5, 0x9811fc2c3ad26669, 0x9e9ac8f996e0b208, 0x8a1d8bc33e26054d, 0xb5badd452da6ca83, 0xe1e08b33d8b96e12, 0xbb4cda05e0ecaea1, 0x7606f25e6319f575, 0x7ae6b459700a9014, 0x6ff383d1c768b8a2, 0x5279c0165cb1b2e0, 0x23ac95f49f5a00d5, 0x4c76fcd0340755fe, 0x87195b667f63fde3, 0x23d35b7b1fbdaf86, 0x91ab80c64650d04a, 0xb865751ac554922e, 0xb7df9b1fe929e730, 0xf95a33b0e999465a, 0x8e023df15c1ba740, 0x0e4a58c66131d3c5, 0x86a4eb7565561e3a, 0xd1e6bd68e105c100, 0xd15f319822a8708f, 0xcd67cec5ea36b7ec, 0x7f45705a53ca5c9a, 0xb211540b2dc7a197, 0xf95bd7472c1e94e0, 0x9c7fb1aa5ef09b8d, 0x9691c490f9480011, 0x23a7f79bb937772e, 0xea07c9d534ac6675, 0xdbca63d742560288, },
	{0xea22b7d69e1fd1ed, 0x996655e9ac81f452, 0xac4d98395072f9b9, 0x6736af52b6ee8918, 0xf7bdbe68b884d498, 0xaeda3515dceb40c0, 0xc384431596ac5ab9, 0x6e51cacc5c82b77d, 0x27eb98a65b9276d3, 0xc036d39e8b0f4f75, 0x73adfffc8930e40a, 0x3f23210db8c3d7eb, 0x10bc8bbca57c8020, 0xd96f0056c24feb59, 0xac4dbdcc3733cd76, 0x0ee5d45cb545a167, 0x80b2d9470ed892a7, 0xa0a39215057c5715, 0xc711eac79f2cef6f, 0x860072ad577c849d, 0xdda75d4d5c3ccaab, 0x4990d965d87f7edf, 0xa389747dbc1d51fe, 0xfecd8888366720a4, 0xe2d8a67939493fee, 0xaa2690c38ff46fea, 0x6a17ebf9b7037b90, 0xdab19ed6e3024ff2, 0x0eb03aeed0936e87, 0x5f633a09049bfadb, 0xb0ffc830ed349227, 0xed550014a1b89116, 0x7ee61ad838dde0d1, 0xd31c8942710b2add, 0x6da5037c0610582c, 0xe68cc2831eaf5924, 0xd4a8db091076d270, 0x6496d89c111553d8, 0xfc97a09de355d3dc, 0x6eb9df808218e038, 0x3f6415d560127315, 0x9063dd494c79e1a8, 0xaf5c73dddacdcd93, 0xda20fffe31d9f1a4, 0x5eff54afe3b72d6d, 0xa2f008e2bf4148e8, 0xc1642c94341c6604, 0x6f4dc6113dcd0733, 0x340c910787fbf1c2, 0x9cd4f48242f6ffad, 0x7ef1b168e5379bfc, 0xb38d7fc7aef6ee0d, 0x10c48d1616709d9b, 0x38819c8054952738, 0xf1231f46b67c1578, 0x229db497d6efd45d, 0xc7117e01cf7a96b2, 0xc9f37b710de4d35e, 0x1b69a26fe66c7b59, 0x20bef96adce394cc, 0xa7d3a44467b26f53, 0x94e841cce751fba1, 0xb3dad33279d0bacd, 0x9b91f15a4e262938, },
	{0x0f934d3f523e8867, 0x7a25f9ef87cb895b, 0x57920f48f4c78f7d, 0xc592394bd8610856, 0xf63efb4dcc54cafa, 0x1c0cbcad973a928e, 0x00d21f5da6bf3fab, 0xdc29a3f24eaacee0, 0xa0baba25f787d74f, 0xffd57f744a580836, 0xd993ece7d6ddcd89, 0xad2876c654796e2f, 0xa42426ede6120917, 0x09a5840850b1c814, 0xa39f1ccc8b9b4ab4, 0x321eb51119316908, 0xd4c4d03d3b80ab1e, 0x11498f8e74d4847d, 0x2ad70a411d95856a, 0x390c516ad3ebe4ce, 0x177d45ec38633008, 0x21ab59f9201c3184, 0xd708138cde5c5312, 0xa409b1f7432263c7, 0xf1883adbddecc1f6, 0xe8dbd89e3c75d30d, 0xcb73076313265854, 0x7e9ec92832f4d1ec, 0x4f319984271211c4, 0xe143121150c92048, 0x4934eec7565f0936, 0x56f8a4fe69947a20, 0x3893f532e3c382b4, 0xc9795514b52a6229, 0xc89862e54a37f7f3, 0xe9f599378920ebf7, 0x620d727af91929fe, 0x2dd413bb4d5049a8, 0xff5b2f412cf5fa68, 0x61b9498b573a0a8f, 0x9ffdad2d2edd4db7, 0xd73678e19d836933, 0x37eac78f4605d749, 0x98cbbcbc61d1566b, 0x3b790b7e5360eca4, 0x4eab8133e5bbe061, 0x9194506b44b2cdcf, 0x18d8210268d19253, 0x48652567a91446ae, 0x549f8bdaf1dd2ba5, 0x13a9fff6871c7c09, 0xc96204c96ece9d0a, 0x0163368bf9d9b2e9, 0x4b6a5c83fba06de7, 0xdcfafbdbe1e4e0ce, 0x162f8b51f18177b5, 0xf8cb887221573e3d, 0x2a4f0f77b56de5ed, 0x6800b74593d3acbe, 0x69cb1cb677cd9717, 0xc5e8f8ef9d5417bc, 0xca925ad0ec54bf5a, 0xce31f3df3227896b, 0xae26d0b1d86dcbea, },
	{0x8e2dfa29db34f095, 0xf45eb4bbbff7c224, 0x533a2d3a20188a4a, 0x0c378a3fafd7c412, 0xf81bb15e1a790d7f, 0x0b19171792b8211e, 0x0be8568d35196363, 0x349cc2c2b37016fe, 0x1e064d27aa1a82d7, 0x47b027a610f8f12c, 0x5f0665076d3038d4, 0x589925c7fbe304c3, 0x99a44ea53299dc85, 0x9efb92df493c1933, 0xdcc884cedbbbbd1c, 0x155e1c1a07763098, 0x7ebc03c0f1db205f, 0x858305bd96a66816, 0x65583087af3631cf, 0x85b4ced9f628f6cc, 0xc2df6067b626833f, 0x25d7651c6379171c, 0x17ee9aa919a44b29, 0xf4b80434e73d9891, 0xba713587f84d7049, 0x0b4e5ebc946afebe, 0x1e8954dfdf3d27f3, 0x86bd346c8013313d, 0xfe111a945126b35f, 0x06f4aa7420261274, 0x222d0df6e04d21b8, 0x1c049748ad08600d, 0xcf0788189283432f, 0x7a4b42fb58c00dc8, 0xe82600aabe3487a3, 0xede81295a84837b0, 0xd54c0694291f538d, 0x71c0c51bd6d44715, 0x3bb9e5d4f07133f3, 0xbcac1a11a739de32, 0xd177d917fe275117, 0xf6f8a4fb64d1a398, 0x65143acc50f8e257, 0x6d55d3d77f357a0a, 0x27dcd0fa022d72af, 0xb4a1824afb493478, 0x90d0c1ee172ee77d, 0xa93c5fa7c2ece6e0, 0x8c4aa19b8a7b2159, 0x470f417e806a3b61, 0xc1212648805435df, 0x50b174aa0d46603c, 0xc5f6a67781bcb86c, 0xdc9c894aea2c7964, 0xf2b7094d5bb80f6d, 0xe35cc8db26c38d03, 0x9aa2b2865dea8108, 0x199deec6f24e587a, 0x49adb32230f26038, 0x49352df3fc28758a, 0x3692b1fd927ef926, 0x756b0b7c6fe2cc51, 0x8cd147ef847bdffb, 0x9e413a00fa819fc5, },
	{0xb95dd68211a941b4, 0x8e58b8b5131feedb, 0xeb3d11fdbfce0c5c, 0x83fbd01544534ccd, 0xa72c3024eec68d67, 0x6775bcdbc12306fb, 0xa4454109310ae3f7, 0xa4df3f2b2ecb8f19, 0xf615fbc0414d0339, 0x5fbe977227dd9f87, 0x52195b8d744aec8f, 0x4a75b0c7ec732c7b, 0x0c725936d7575661, 0x8857af6b685bea16, 0xe33a2da28b9a0183, 0x51760c5ef369cd99, 0x684e5528d4eaa1f0, 0x4d21f2886b83f6a3, 0x788ea0863dc763be, 0x1a8e4272b478b51c, 0x0c1cff417e8bedd5, 0xc7a35e4cc77c1220, 0xc45747b12b759161, 0x12c863699cf4f840, 0xb2e7f8e332181774, 0x466b1d6630c94dd0, 0x234011cb06955a59, 0x1f65701c45b07ab4, 0x206c1f6cc270a3f7, 0x965f51dc57ac9c88, 0x60780cb746adfaa3, 0x364118912f6f32c0, 0x5d9b5b125700e770, 0xb2aeaf41baf52f52, 0x9bbc0c04050f828a, 0xe0b10b3c65f08a82, 0xf2eff33b4ade2ca9, 0x8cae120fe2f92cfd, 0x347e55a963ea7e58, 0x32db98d75454032d, 0x0972a6040c6c14d8, 0x9c4537d0522f9a60, 0x16e83c2441017d97, 0xd553414b4dfd6449, 0xd95ce1aeeec4894c, 0x9d080ec8288789c2, 0x6238011eafcfb2a5, 0x44418b6882c0029b, 0x975fffc3844f3caa, 0x69ed08b79fd62961, 0xa500b17ff7a1bc85, 0x39bf5d4a9806b977, 0xa8b4b1c4eb0a2d42, 0x6bd252de188879d2, 0x2c41a5ff658fc260, 0x8ae119ec71d68d62, 0x3a04baabccb8e540, 0x1ec711db3cc08b8b, 0x194b106d421a9ec2, 0x07124abaa0954d9f, 0x6fd378c7573f3754, 0xa607640f9418b4af, 0xfe2eaec30bcd6e95, 0xbb34b3ce1253a0eb, },
	{0x06bcb0ab6c797a22, 0x37438fd3bc5fcd58, 0x90f3837dfc6757c2, 0x97c0d51ce3d94404, 0x513b4966586a4f04, 0x16a919661ba30bb8, 0x620481089083f237, 0x57968a064a4ce24e, 0x184ba819ded502fd, 0x864727ce428ba4f3, 0xb4341c9cd048983c, 0xa841f9a0f81e0d92, 0x06fedf060eb5f074, 0xb7dc736fbbd7a248, 0xe5b548fe4af23a3c, 0xd7328b12cfcc8822, 0x260d52e34046558f, 0x99979ced186b010a, 0x3f4b6832bb3592cb, 0x889e2dce4f4d81b4, 0x9eb2752c3e179c08, 0xaf778a652699aa27, 0x4437d96e3129c86e, 0xb143df07502b3d44, 0x78375c234d122d90, 0xfaf1d80c55e8da29, 0x66858af225d8c857, 0x4867a9490c6aa918, 0x63a0b8a8c2218a98, 0x61642eeee5c87bdf, 0xfd3fe7802a2c3430, 0x46b9332fa4135f64, 0xb4d1722d3379cd78, 0x0d6c6ea535cd304a, 0x8591f2dd76253e1e, 0x870740fa25f58b5a, 0xa6e8b960ba719dbd, 0x099d5d2a2ec7be9f, 0x88d11a172b43f5a4, 0xccb45ab60949c383, 0x64252d0b620db971, 0x7acf101dfb4d96e3, 0xaacce6fd4132df8b, 0xbff99cffa316c233, 0xcf25858b6d6c069f, 0xabc2c7ec50a0fb37, 0xed391a8287df3be7, 0x0144e6bce43fe5af, 0xf42b4aab444a5a04, 0xc4427f7b51921a6a, 0x5acfd1471c86034c, 0x9a522e32a4237630, 0xeae098aca385b7ce, 0x518c9a5066cde635, 0x82d67e6a6405b9a4, 0x8989f3fc3d2eb9df, 0xf9efcca6e6dacd52, 0x133c6d8978cbf19e, 0xc81b13c5fa0721b9, 0x04715a3ffabed74e, 0x746d0d6f1f2a5157, 0x79226282e7d4e0ce, 0xc491470411d56650, 0x3b8cf4204116a369, },
	{0x6f0843df7b8b3d8a, 0x2d16ccc120672aa7, 0x1b52e18f59d0e0e8, 0x6b7391a223abb41c, 0x018d58bb1adfa5fb, 0x381fb3f0d3d5e06a, 0x1c183c0166391267, 0x82cfaef108900e67, 0x4d20c6aff128b801, 0xe79f47b00f4df3fd, 0xeb84dfa3b034f17f, 0xca7cce0db49d6006, 0x82f156285e75e1c5, 0xe58a51166ba2e0ea, 0x5828e2c3a97c3f58, 0xd7e6c273c4a7800b, 0xf13fb89b93dde9e0, 0xf586d7ddbdd20e1f, 0x6333565dff9a3526, 0xec64f6a7482e4082, 0x2b1f59067382e47e, 0x4fa2f681462776a6, 0x2fa29b35997bf5e4, 0xaf2c2063ac671220, 0x385061ff10955258, 0x4612350d9a16f0d4, 0x0d733d8ac173dfb0, 0x0d846c2913174f81, 0x1f845aa45e4606f2, 0x78dbcc150ae05994, 0x9efb463c10569d65, 0x779ad2e7a020e2d3, 0x3e0e248d50f6c50c, 0xec209f6252f5d08d, 0x748dd9cb161ce7e4, 0x31878a48370653df, 0x63b2f725dcb81141, 0xfc580c72735384a9, 0xbb8a45cb73ff9a0d, 0x8a089d34bfc2fb76, 0x603bd99afacd5bb2, 0xb62cad7596e2c206, 0x5035ea10593488f4, 0xef0d40bcb58a560f, 0x22d77b6e2b22bfd4, 0x4fd7556e189798cf, 0x57ba62f2f65547ef, 0xcf59e3bfc5179e39, 0x538837bc6387f2f0, 0x29b6bf1b025210e5, 0xc608498447604b09, 0x90da9248d6cf7631, 0xeec8a090304bac12, 0xf54ce6966021881b, 0x89bbda3b9a5b0ce9, 0xcfb8e41c9455b78d, 0xa393bdedf8236c4e, 0x2d31932821510d24, 0x863bbc78216f5883, 0xa3dd13d406dd5a57, 0xaf764609a6c5d851, 0x156a79b326bb4507, 0xa9481d95854f1d04, 0x41942991fc8b41d4, },
};

#endif // CHESS_ZOBRIST_TABLES_H


zobrist_t zobrist_flip_turn(zobrist_t zobrist) {
  return zobrist ^ zobrist_black_to_move;
}

zobrist_t zobrist_flip_piece(zobrist_t zobrist, piece_t piece,
                             sq0x88_t square) {
  // found using godbolt that this is more efficient than a switch (avoids code branching)
  const int8_t piece_to_zobrist_index_map[17] = {
    -1,
    0,
    1,
    -1,
    2,
    -1,
    -1,
    -1,
    3,
    -1,
    -1,
    -1,
    4,
    -1,
    -1,
    -1,
    5,
  };
  int piece_index = piece_to_zobrist_index_map[piece & PIECE_MASK] + ((piece & COLOUR_MASK) == WHITE ? 0 : 6);
  int square_index = sq0x88_to_sq8x8(square);
  return zobrist ^ zobrist_table[piece_index][square_index];
}

zobrist_t zobrist_move_piece(zobrist_t zobrist, piece_t piece,
                             sq0x88_t from, sq0x88_t to) {
  // found using godbolt that this is more efficient than a switch (avoids code branching)
  const int8_t piece_to_zobrist_index_map[17] = {
    -1,
    0,
    1,
    -1,
    2,
    -1,
    -1,
    -1,
    3,
    -1,
    -1,
    -1,
    4,
    -1,
    -1,
    -1,
    5,
  };
  int piece_index = piece_to_zobrist_index_map[piece & PIECE_MASK] + ((piece & COLOUR_MASK) == WHITE ? 0 : 6);
  int from_index = sq0x88_to_sq8x8(from);
  int to_index = sq0x88_to_sq8x8(to);
  return zobrist ^ zobrist_table[piece_index][from_index] ^ zobrist_table[piece_index][to_index];

}
// Expanded from src/chess/move_generation.c

#ifdef PM_USE_AVX
#include <immintrin.h>
#endif

#include <stdlib.h>

// Expanded from include/increments.h
#ifndef INCREMENTS_H
#define INCREMENTS_H


#define KING_INCREMENTS_COUNT 8
#define QUEEN_INCREMENTS_COUNT 8
#define KNIGHT_INCREMENTS_COUNT 8
#define BISHOP_INCREMENTS_COUNT 4
#define ROOK_INCREMENTS_COUNT 4

static const sq0x88_t king_increments_list[KING_INCREMENTS_COUNT] = {1, 255, 240, 16, 241, 239, 15, 17};
static const sq0x88_t knight_increments_list[KNIGHT_INCREMENTS_COUNT] = {18, 14, 33, 31, 242, 238, 225, 223};
static const sq0x88_t queen_increments_list[QUEEN_INCREMENTS_COUNT] = {1, 255, 240, 16, 241, 239, 15, 17};
static const sq0x88_t bishop_increments_list[BISHOP_INCREMENTS_COUNT] = {241, 239, 15, 17};
static const sq0x88_t rook_increments_list[ROOK_INCREMENTS_COUNT] = {1, 255, 240, 16};


#define INCREMENT_VECTOR_SIZE 240

static const sq0x88_t queen_increment_vector[INCREMENT_VECTOR_SIZE] = {
    239,0,  0,  0,  0,  0,  0,  240,0,  0,  0,  0,  0,  0,  241,0,  
    0,  239,0,  0,  0,  0,  0,  240,0,  0,  0,  0,  0,  241,0,  0,  
    0,  0,  239,0,  0,  0,  0,  240,0,  0,  0,  0,  241,0,  0,  0,  
    0,  0,  0,  239,0,  0,  0,  240,0,  0,  0,  241,0,  0,  0,  0,  
    0,  0,  0,  0,  239,0,  0,  240,0,  0,  241,0,  0,  0,  0,  0,  
    0,  0,  0,  0,  0,  239,0,  240,0,  241,0,  0,  0,  0,  0,  0,  
    0,  0,  0,  0,  0,  0,  239,240,241,0,  0,  0,  0,  0,  0,  0,  
    255,255,255,255,255,255,255,0,  1,  1,  1,  1,  1,  1,  1,  0,  
    0,  0,  0,  0,  0,  0,  15, 16, 17, 0,  0,  0,  0,  0,  0,  0,  
    0,  0,  0,  0,  0,  15, 0,  16, 0,  17, 0,  0,  0,  0,  0,  0,  
    0,  0,  0,  0,  15 ,0,  0,  16, 0,  0,  17, 0,  0,  0,  0,  0,
    0,  0,  0,  15, 0,  0,  0,  16, 0,  0,  0,  17, 0,  0,  0,  0,  
    0,  0,  15, 0,  0,  0,  0,  16, 0,  0,  0,  0,  17, 0,  0,  0,  
    0,  15, 0,  0,  0,  0,  0,  16, 0,  0,  0,  0,  0,  17, 0,  0,  
    15, 0,  0,  0,  0,  0,  0,  16, 0,  0,  0,  0,  0,  0,  17, 0,  
};

static const sq0x88_t rook_increment_vector[INCREMENT_VECTOR_SIZE] = {
    0,  0,  0,  0,  0,  0,  0,  240,0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  240,0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  240,0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  240,0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  240,0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  240,0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  240,0,  0,  0,  0,  0,  0,  0,  0,
    255,255,255,255,255,255,255,0,  1,  1,  1,  1,  1,  1,  1,  0,
    0,  0,  0,  0,  0,  0,  0,  16, 0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  16, 0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  16, 0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  16, 0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  16, 0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  16, 0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  16, 0,  0,  0,  0,  0,  0,  0,  0,
};

static const sq0x88_t bishop_increment_vector[INCREMENT_VECTOR_SIZE] = {
    239,0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  241,0,  
    0,  239,0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  241,0,  0,  
    0,  0,  239,0,  0,  0,  0,  0,  0,  0,  0,  0,  241,0,  0,  0,  
    0,  0,  0,  239,0,  0,  0,  0,  0,  0,  0,  241,0,  0,  0,  0,  
    0,  0,  0,  0,  239,0,  0,  0,  0,  0,  241,0,  0,  0,  0,  0,  
    0,  0,  0,  0,  0,  239,0,  0,  0,  241,0,  0,  0,  0,  0,  0,  
    0,  0,  0,  0,  0,  0,  239,0,  241,0,  0,  0,  0,  0,  0,  0,  
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
    0,  0,  0,  0,  0,  0,  15, 0,  17, 0,  0,  0,  0,  0,  0,  0,  
    0,  0,  0,  0,  0,  15, 0,  0,  0,  17, 0,  0,  0,  0,  0,  0,  
    0,  0,  0,  0,  15, 0,  0,  0,  0,  0,  17, 0,  0,  0,  0,  0,  
    0,  0,  0,  15, 0,  0,  0,  0,  0,  0,  0,  17, 0,  0,  0,  0,  
    0,  0,  15, 0,  0,  0,  0,  0,  0,  0,  0,  0,  17, 0,  0,  0,  
    0,  15, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  17, 0,  0,  
    15, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  17, 0,  
};

static const sq0x88_t knight_increment_vector[INCREMENT_VECTOR_SIZE] = {
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  223,0,  225,0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  238,0,  0,  0,  242,0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  14, 0,  0,  0,  18, 0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  31, 0, 33,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
};
static const sq0x88_t king_increment_vector[INCREMENT_VECTOR_SIZE] = {
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  239,240,241,0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  255,0,  1,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  15, 16, 17, 0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
};

#endif

// todo
// make piece list base move generation functions i.e. size_t
// generate_moves_internal(const chess_state_t* chess_state, const piece_list_t*
// piece_lists, move_t* moves); make incremental move generation functions i.
// size_t generate_captures(const chess_state_t* chess_state, move_t * moves);

int can_capture_enpassent(const chess_state_t* chess_state, sq0x88_t from,
                          colour_t colour) {
  sq0x88_t inc = pawn_push_increment(colour);
  sq0x88_t target = enpassent_target(chess_state);
  return colour == chess_state->friendly_colour &&
         sq0x88_to_rank07(from + inc) == sq0x88_to_rank07(target) &&
         abs(sq0x88_to_file07(from) - sq0x88_to_file07(target)) == 1;
}

// king helper functions

int can_castle_king_side(const chess_state_t* chess_state, colour_t colour) {
  sq0x88_t king_square = get_piece_list(chess_state, colour)->king_square;
  return ((colour == WHITE &&
           (chess_state->castle_rights & WHITE_KING_SIDE) != 0) ||
          (colour == BLACK &&
           (chess_state->castle_rights & BLACK_KING_SIDE) != 0)) &&
         piece(chess_state, king_square + 1) == EMPTY &&
         piece(chess_state, king_square + 2) == EMPTY;
}

int can_castle_queen_side(const chess_state_t* chess_state, colour_t colour) {
  sq0x88_t king_square = get_piece_list(chess_state, colour)->king_square;
  return ((colour == WHITE &&
           (chess_state->castle_rights & WHITE_QUEEN_SIDE) != 0) ||
          (colour == BLACK &&
           (chess_state->castle_rights & BLACK_QUEEN_SIDE) != 0)) &&
         piece(chess_state, king_square - 1) == EMPTY &&
         piece(chess_state, king_square - 2) == EMPTY &&
         piece(chess_state, king_square - 3) == EMPTY;
}

// knight movement

size_t knight_moves(const chess_state_t* chess_state, move_t* moves,
                    size_t move_count, sq0x88_t from, colour_t colour) {
  for (int i = 0; i < KNIGHT_INCREMENTS_COUNT; i++) {
    sq0x88_t to = from + knight_increments_list[i];
    if (off_the_board(to) || piece_is_colour(chess_state, to, colour)) {
      continue;
    }
    piece_t target_piece = piece(chess_state, to);
    if (target_piece == EMPTY) {
      moves[move_count++] = move(from, to, QUIET_MOVE);
    } else if (target_piece != EMPTY) {
      moves[move_count++] = move(from, to, CAPTURE);
    }
  }
  return move_count;
}

size_t knight_captures(const chess_state_t* chess_state, move_t* moves,
                       size_t move_count, sq0x88_t from, colour_t colour) {
  for (int i = 0; i < KNIGHT_INCREMENTS_COUNT; i++) {
    sq0x88_t to = from + knight_increments_list[i];
    if (off_the_board(to) || piece_is_colour(chess_state, to, colour)) {
      continue;
    }
    piece_t target_piece = piece(chess_state, to);
    if (target_piece != EMPTY) {
      moves[move_count++] = move(from, to, CAPTURE);
    }
  }
  return move_count;
}

size_t knight_quiets(const chess_state_t* chess_state, move_t* moves,
                     size_t move_count, sq0x88_t from) {
  for (int i = 0; i < KNIGHT_INCREMENTS_COUNT; i++) {
    sq0x88_t to = from + knight_increments_list[i];
    if (off_the_board(to) || piece(chess_state, to) != EMPTY) {
      continue;
    }
    moves[move_count++] = move(from, to, QUIET_MOVE);
  }
  return move_count;
}

size_t king_moves(const chess_state_t* chess_state, move_t* moves,
                  size_t move_count, sq0x88_t king_square, colour_t colour) {
  for (int i = 0; i < KING_INCREMENTS_COUNT; i++) {
    sq0x88_t to = king_square + king_increments_list[i];
    if (off_the_board(to) || piece_is_colour(chess_state, to, colour)) {
      continue;
    }
    piece_t target_piece = piece(chess_state, to);
    if (target_piece == EMPTY) {
      moves[move_count++] = move(king_square, to, QUIET_MOVE);
    } else if (target_piece != EMPTY) {
      moves[move_count++] = move(king_square, to, CAPTURE);
    }
  }

  return move_count;
}

size_t king_captures(const chess_state_t* chess_state, move_t* moves,
                     size_t move_count, sq0x88_t king_square, colour_t colour) {
  for (int i = 0; i < KING_INCREMENTS_COUNT; i++) {
    sq0x88_t to = king_square + king_increments_list[i];
    if (off_the_board(to) || piece_is_colour(chess_state, to, colour)) {
      continue;
    }
    piece_t target_piece = piece(chess_state, to);
    if (target_piece != EMPTY) {
      moves[move_count++] = move(king_square, to, CAPTURE);
    }
  }

  return move_count;
}

size_t king_quiets(const chess_state_t* chess_state, move_t* moves,
                   size_t move_count, sq0x88_t king_square) {
  for (int i = 0; i < KING_INCREMENTS_COUNT; i++) {
    sq0x88_t to = king_square + king_increments_list[i];

    if (off_the_board(to) || piece(chess_state, to) != EMPTY) {
      continue;
    }
    moves[move_count++] = move(king_square, to, QUIET_MOVE);
  }

  return move_count;
}

size_t castling_moves(const chess_state_t* chess_state, move_t* moves,
                      size_t move_count, sq0x88_t king_square,
                      colour_t colour) {
  // castling
  if (can_castle_king_side(chess_state, colour)) {
    moves[move_count++] = move(king_square, king_square + 2, KING_CASTLE);
  }
  if (can_castle_queen_side(chess_state, colour)) {
    moves[move_count++] = move(king_square, king_square - 2, QUEEN_CASTLE);
  }
  return move_count;
}

#define CAST_MOVE_AS_INT(...) (*(uint32_t*)&(__VA_ARGS__))

// flags should either be QUIET_MOVE or CAPTURE, add_promotion_moves will handle
// the promotion flags
size_t add_promotion_moves(move_t* moves, size_t move_count, sq0x88_t from,
                           sq0x88_t to, int flags) {
#ifdef PM_USE_AVX
  const __m128i promotion_flags = (__m128i){
      (uint64_t)CAST_MOVE_AS_INT((move_t){0, 0, QUEEN_PROMOTION}) << 0 |
      (uint64_t)CAST_MOVE_AS_INT((move_t){0, 0, ROOK_PROMOTION}) << 32,
      (uint64_t)CAST_MOVE_AS_INT((move_t){0, 0, BISHOP_PROMOTION}) << 0 |
      (uint64_t)CAST_MOVE_AS_INT((move_t){0, 0, KNIGHT_PROMOTION}) << 32,
  };
  move_t move_no_promote_flag = move(from, to, flags);
  __m128i moves_no_promote = _mm_set1_epi32(CAST_MOVE_AS_INT(move_no_promote_flag));
  __m128i moves_promote = moves_no_promote ^ promotion_flags;
  _mm_storeu_si128((__m128i*)(moves + move_count), moves_promote);
  return move_count + 4;
#else
  moves[move_count++] = move(from, to, flags | QUEEN_PROMOTION);
  moves[move_count++] = move(from, to, flags | ROOK_PROMOTION);
  moves[move_count++] = move(from, to, flags | BISHOP_PROMOTION);
  moves[move_count++] = move(from, to, flags | KNIGHT_PROMOTION);
  return move_count;
#endif
}

size_t pawn_moves(const chess_state_t* chess_state, move_t* moves,
                  size_t move_count, sq0x88_t from, colour_t colour) {
  // if is promoting
  sq0x88_t inc = pawn_push_increment(colour);
  colour_t enemy_colour = opposite_colour(colour);
  sq0x88_t to = from + inc;
  if (is_promoting(from, colour)) {
    if (piece(chess_state, to) == EMPTY) {
      move_count = add_promotion_moves(moves, move_count, from, to, QUIET_MOVE);
    }
    to = from + inc + 1;
    if (!off_the_board(to) && piece_is_colour(chess_state, to, enemy_colour)) {
      move_count = add_promotion_moves(moves, move_count, from, to, CAPTURE);
    }
    to = from + inc - 1;
    if (!off_the_board(to) && piece_is_colour(chess_state, to, enemy_colour)) {
      move_count = add_promotion_moves(moves, move_count, from, to, CAPTURE);
    }
    return move_count;
  }
  if (piece(chess_state, to) == EMPTY) {
    moves[move_count++] = move(from, to, QUIET_MOVE);
    to = from + 2 * inc;
    if (pawn_can_double_push(from, colour) && piece(chess_state, to) == EMPTY) {
      moves[move_count++] = move(from, to, DOUBLE_PAWN_PUSH);
    }
  }

  to = from + inc + 1;
  if (!off_the_board(to) && piece_is_colour(chess_state, to, enemy_colour)) {
    moves[move_count++] = move(from, to, CAPTURE);
  }
  to = from + inc - 1;
  if (!off_the_board(to) && piece_is_colour(chess_state, to, enemy_colour)) {
    moves[move_count++] = move(from, to, CAPTURE);
  }

  return move_count;
}

size_t enpassent_captures(const chess_state_t* chess_state, move_t* moves,
                          size_t move_count, colour_t colour) {
  if (off_the_board(enpassent_target(chess_state))) {
    return move_count;
  }

  sq0x88_t to = enpassent_target(chess_state);
  sq0x88_t from;

  sq0x88_t inc = pawn_push_increment(colour);

  from = to - inc - 1;
  if (!off_the_board(from) && piece(chess_state, from) == (colour | PAWN)) {
    moves[move_count++] = move(from, to, ENPASSENT);
  }
  from = to - inc + 1;
  if (!off_the_board(from) && piece(chess_state, from) == (colour | PAWN)) {
    moves[move_count++] = move(from, to, ENPASSENT);
  }

  return move_count;
}

size_t pawn_captures(const chess_state_t* chess_state, move_t* moves,
                     size_t move_count, sq0x88_t from, colour_t colour) {
  // if is promoting
  sq0x88_t inc = pawn_push_increment(colour);
  colour_t enemy_colour = opposite_colour(colour);
  sq0x88_t to = from + inc;
  if (is_promoting(from, colour)) {
    return move_count;
  }
  to = from + inc + 1;
  if (!off_the_board(to) && piece_is_colour(chess_state, to, enemy_colour)) {
    moves[move_count++] = move(from, to, CAPTURE);
  }
  to = from + inc - 1;
  if (!off_the_board(to) && piece_is_colour(chess_state, to, enemy_colour)) {
    moves[move_count++] = move(from, to, CAPTURE);
  }

  return move_count;
}

size_t pawn_quiets(const chess_state_t* chess_state, move_t* moves,
                   size_t move_count, sq0x88_t from, colour_t colour) {
  // if is promoting
  sq0x88_t inc = pawn_push_increment(colour);
  sq0x88_t to = from + inc;
  if (is_promoting(from, colour)) {
    return move_count;
  }
  if (!off_the_board(to) && piece(chess_state, to) == EMPTY) {
    moves[move_count++] = move(from, to, QUIET_MOVE);
  }
  to = from + 2 * inc;
  if (!off_the_board(to) && piece(chess_state, to) == EMPTY &&
      piece(chess_state, to - inc) == EMPTY &&
      pawn_can_double_push(from, colour)) {
    moves[move_count++] = move(from, to, DOUBLE_PAWN_PUSH);
  }

  return move_count;
}

size_t pawn_promotions(const chess_state_t* chess_state, move_t* moves,
                       size_t move_count, sq0x88_t from, colour_t colour) {
  // if is promoting
  sq0x88_t inc = pawn_push_increment(colour);
  colour_t enemy_colour = opposite_colour(colour);
  sq0x88_t to = from + inc;
  if (!is_promoting(from, colour)) {
    return move_count;
  }
  if (piece(chess_state, to) == EMPTY) {
    move_count = add_promotion_moves(moves, move_count, from, to, QUIET_MOVE);
  }
  to = from + inc + 1;
  if (!off_the_board(to) && piece_is_colour(chess_state, to, enemy_colour)) {
    move_count = add_promotion_moves(moves, move_count, from, to, CAPTURE);
  }
  to = from + inc - 1;
  if (!off_the_board(to) && piece_is_colour(chess_state, to, enemy_colour)) {
    move_count = add_promotion_moves(moves, move_count, from, to, CAPTURE);
  }
  return move_count;
}

size_t sliding_moves(const chess_state_t* chess_state, move_t* moves,
                     size_t move_count, sq0x88_t from, colour_t colour,
                     const sq0x88_t* increments, int increments_count) {
  for (sq0x88_t i = 0; i < increments_count; i++) {
    sq0x88_t inc = increments[i];
    sq0x88_t to;
    for (to = from + inc; piece(chess_state, to) == EMPTY; to += inc) {
      moves[move_count++] = move(from, to, QUIET_MOVE);
    }
    if (off_the_board(to) || piece_is_colour(chess_state, to, colour)) continue;

    moves[move_count++] = move(from, to, CAPTURE);
  }
  return move_count;
}

size_t sliding_quiets(const chess_state_t* chess_state, move_t* moves,
                      size_t move_count, sq0x88_t from,
                      const sq0x88_t* increments, int increments_count) {
  for (sq0x88_t i = 0; i < increments_count; i++) {
    sq0x88_t inc = increments[i];
    sq0x88_t to;
    for (to = from + inc; piece(chess_state, to) == EMPTY; to += inc) {
      moves[move_count++] = move(from, to, QUIET_MOVE);
    }
  }
  return move_count;
}

size_t sliding_captures(const chess_state_t* chess_state, move_t* moves,
                        size_t move_count, sq0x88_t from, colour_t colour,
                        const sq0x88_t* increments, int increments_count) {
  for (sq0x88_t i = 0; i < increments_count; i++) {
    sq0x88_t inc = increments[i];
    sq0x88_t to = forwards_ray_cast(chess_state, from, inc);
    if (off_the_board(to) || piece_is_colour(chess_state, to, colour)) continue;

    moves[move_count++] = move(from, to, CAPTURE);
  }
  return move_count;
}

size_t generate_moves_nocheck_internal(const chess_state_t* chess_state,
                                       move_t* moves, colour_t colour) {
  size_t move_count = 0;
  const piece_list_t* piece_lists = get_piece_list(chess_state, colour);
  move_count = castling_moves(chess_state, moves, move_count,
                              piece_lists->king_square, colour);

  move_count = king_moves(chess_state, moves, move_count,
                          piece_lists->king_square, colour);

  FOR_EACH_PIECE(piece_lists, queen, square) {
    move_count = sliding_moves(chess_state, moves, move_count, square, colour,
                               queen_increments_list, QUEEN_INCREMENTS_COUNT);
  }

  FOR_EACH_PIECE(piece_lists, rook, square) {
    move_count = sliding_moves(chess_state, moves, move_count, square, colour,
                               rook_increments_list, ROOK_INCREMENTS_COUNT);
  }

  FOR_EACH_PIECE(piece_lists, light_bishop, square) {
    move_count = sliding_moves(chess_state, moves, move_count, square, colour,
                               bishop_increments_list, BISHOP_INCREMENTS_COUNT);
  }

  FOR_EACH_PIECE(piece_lists, dark_bishop, square) {
    move_count = sliding_moves(chess_state, moves, move_count, square, colour,
                               bishop_increments_list, BISHOP_INCREMENTS_COUNT);
  }

  FOR_EACH_PIECE(piece_lists, knight, square) {
    move_count = knight_moves(chess_state, moves, move_count, square, colour);
  }

  FOR_EACH_PIECE(piece_lists, pawn, square) {
    move_count = pawn_moves(chess_state, moves, move_count, square, colour);
  }

  move_count = enpassent_captures(chess_state, moves, move_count, colour);

  return move_count;
}

size_t generate_captures_nocheck_internal(const chess_state_t* chess_state,
                                          move_t* moves, colour_t colour) {
  size_t move_count = 0;
  const piece_list_t* piece_lists = get_piece_list(chess_state, colour);

  move_count = king_captures(chess_state, moves, move_count,
                             piece_lists->king_square, colour);

  FOR_EACH_PIECE(piece_lists, queen, square) {
    move_count =
        sliding_captures(chess_state, moves, move_count, square, colour,
                         queen_increments_list, QUEEN_INCREMENTS_COUNT);
  }

  FOR_EACH_PIECE(piece_lists, rook, square) {
    move_count =
        sliding_captures(chess_state, moves, move_count, square, colour,
                         rook_increments_list, ROOK_INCREMENTS_COUNT);
  }

  FOR_EACH_PIECE(piece_lists, light_bishop, square) {
    move_count =
        sliding_captures(chess_state, moves, move_count, square, colour,
                         bishop_increments_list, BISHOP_INCREMENTS_COUNT);
  }

  FOR_EACH_PIECE(piece_lists, dark_bishop, square) {
    move_count =
        sliding_captures(chess_state, moves, move_count, square, colour,
                         bishop_increments_list, BISHOP_INCREMENTS_COUNT);
  }

  FOR_EACH_PIECE(piece_lists, knight, square) {
    move_count =
        knight_captures(chess_state, moves, move_count, square, colour);
  }

  FOR_EACH_PIECE(piece_lists, pawn, square) {
    move_count = pawn_captures(chess_state, moves, move_count, square, colour);
  }

  move_count = enpassent_captures(chess_state, moves, move_count, colour);

  return move_count;
}

size_t generate_quiets_nocheck_internal(const chess_state_t* chess_state,
                                        move_t* moves, colour_t colour) {
  size_t move_count = 0;
  const piece_list_t* piece_lists = get_piece_list(chess_state, colour);
  move_count = castling_moves(chess_state, moves, move_count,
                              piece_lists->king_square, colour);

  move_count = king_quiets(chess_state, moves, move_count,
                           piece_lists->king_square);

  FOR_EACH_PIECE(piece_lists, queen, square) {
    move_count = sliding_quiets(chess_state, moves, move_count, square,
                                queen_increments_list, QUEEN_INCREMENTS_COUNT);
  }

  FOR_EACH_PIECE(piece_lists, rook, square) {
    move_count = sliding_quiets(chess_state, moves, move_count, square,
                                rook_increments_list, ROOK_INCREMENTS_COUNT);
  }

  FOR_EACH_PIECE(piece_lists, light_bishop, square) {
    move_count =
        sliding_quiets(chess_state, moves, move_count, square,
                       bishop_increments_list, BISHOP_INCREMENTS_COUNT);
  }

  FOR_EACH_PIECE(piece_lists, dark_bishop, square) {
    move_count =
        sliding_quiets(chess_state, moves, move_count, square,
                       bishop_increments_list, BISHOP_INCREMENTS_COUNT);
  }

  FOR_EACH_PIECE(piece_lists, knight, square) {
    move_count = knight_quiets(chess_state, moves, move_count, square);
  }

  FOR_EACH_PIECE(piece_lists, pawn, square) {
    move_count = pawn_quiets(chess_state, moves, move_count, square, colour);
  }

  return move_count;
}

size_t generate_promotions_nocheck_internal(const chess_state_t* chess_state,
                                            move_t* moves, colour_t colour) {
  size_t move_count = 0;
  const piece_list_t* piece_lists = get_piece_list(chess_state, colour);

  FOR_EACH_PIECE(piece_lists, pawn, square) {
    move_count =
        pawn_promotions(chess_state, moves, move_count, square, colour);
  }

  return move_count;
}

int sliding_can_reach(const chess_state_t* chess_state, sq0x88_t from,
                      sq0x88_t target, sq0x88_t inc) {
  return inc && backwards_ray_cast(chess_state, target, inc) == from;
}

int sliding_can_capture(const chess_state_t* chess_state, sq0x88_t from,
                        sq0x88_t target, sq0x88_t inc) {
  return inc && forwards_ray_cast(chess_state, from, inc) == target;
}

size_t generate_captures_of(const chess_state_t* chess_state, move_t* moves,
                            size_t move_count, colour_t colour,
                            sq0x88_t target) {
  const piece_list_t* piece_lists = get_piece_list(chess_state, colour);
  // queen moves
  FOR_EACH_PIECE(piece_lists, queen, square) {
    if (sliding_can_capture(chess_state, square, target,
                            queen_increment(square, target))) {
      moves[move_count++] = move(square, target, CAPTURE);
    }
  }

  // rook moves
  FOR_EACH_PIECE(piece_lists, rook, square) {
    if (sliding_can_capture(chess_state, square, target,
                            rook_increment(square, target))) {
      moves[move_count++] = move(square, target, CAPTURE);
    }
  }

  if (is_light_square(target)) {
    // light bishop moves
    FOR_EACH_PIECE(piece_lists, light_bishop, square) {
      if (sliding_can_capture(chess_state, square, target,
                              bishop_increment(square, target))) {
        moves[move_count++] = move(square, target, CAPTURE);
      }
    }
  } else {
    // dark bishop moves
    FOR_EACH_PIECE(piece_lists, dark_bishop, square) {
      if (sliding_can_capture(chess_state, square, target,
                              bishop_increment(square, target))) {
        moves[move_count++] = move(square, target, CAPTURE);
      }
    }
  }

  // knight moves
  FOR_EACH_PIECE(piece_lists, knight, square) {
    if (knight_increment(square, target)) {
      moves[move_count++] = move(square, target, CAPTURE);
    }
  }
  // pawn captures
  sq0x88_t inc = pawn_push_increment(colour);
  sq0x88_t from;
  piece_t friendly_pawn = colour | PAWN;
  if (is_promoting(target - inc, colour)) {
    return move_count;
  }
  from = target - inc + 1;
  if (!off_the_board(from) && piece(chess_state, from) == friendly_pawn) {
    moves[move_count++] = move(from, target, CAPTURE);
  }

  from = target - inc - 1;
  if (!off_the_board(from) && piece(chess_state, from) == friendly_pawn) {
    moves[move_count++] = move(from, target, CAPTURE);
  }

  if (enpassent_target(chess_state) == target + inc) {
    move_count = enpassent_captures(chess_state, moves, move_count, colour);
  }
  return move_count;
}

size_t generate_promotion_captures_of(const chess_state_t* chess_state,
                                      move_t* moves, size_t move_count,
                                      colour_t colour, sq0x88_t target) {
  // const piece_list_t* piece_lists = get_piece_list(chess_state, colour);
  if (sq8x8_to_rank07(target) != backrank(colour)) {
    return move_count;
  }
  sq0x88_t inc = pawn_push_increment(colour);
  sq0x88_t from;
  piece_t friendly_pawn = colour | PAWN;
  from = target - inc + 1;
  if (!off_the_board(from) && piece(chess_state, from) == friendly_pawn) {
    move_count = add_promotion_moves(moves, move_count, from, target, CAPTURE);
  }
  from = target - inc - 1;
  if (!off_the_board(from) && piece(chess_state, from) == friendly_pawn) {
    move_count = add_promotion_moves(moves, move_count, from, target, CAPTURE);
  }

  return move_count;
}

size_t generate_promotion_interposing_moves(const chess_state_t* chess_state,
                                            move_t* moves, size_t move_count,
                                            colour_t colour, sq0x88_t start,
                                            sq0x88_t stop, sq0x88_t inc) {
  if (sq0x88_to_rank07(start) != backrank(colour) ||
      sq0x88_to_rank07(stop) != backrank(colour)) {
    return move_count;
  }
  // pawn moves
  sq0x88_t pawn_inc = pawn_push_increment(colour);
  piece_t friendly_pawn = PAWN | colour;
  for (sq0x88_t target = start; target != stop; target += inc) {
    sq0x88_t from;
    from = target - pawn_inc;
    if (!off_the_board(from) && piece(chess_state, from) == friendly_pawn) {
      move_count =
          add_promotion_moves(moves, move_count, from, target, QUIET_MOVE);
    }
  }

  return move_count;
}

size_t generate_interposing_moves(const chess_state_t* chess_state,
                                  move_t* moves, size_t move_count,
                                  colour_t colour, sq0x88_t start,
                                  sq0x88_t stop, sq0x88_t inc) {
  const piece_list_t* piece_lists = get_piece_list(chess_state, colour);
  // queen moves
  FOR_EACH_PIECE(piece_lists, queen, square) {
    for (sq0x88_t target = start; target != stop; target += inc) {
      if (sliding_can_reach(chess_state, square, target,
                            queen_increment(square, target))) {
        moves[move_count++] = move(square, target, QUIET_MOVE);
      }
    }
  }

  // rook moves
  FOR_EACH_PIECE(piece_lists, rook, square) {
    for (sq0x88_t target = start; target != stop; target += inc) {
      if (sliding_can_reach(chess_state, square, target,
                            rook_increment(square, target))) {
        moves[move_count++] = move(square, target, QUIET_MOVE);
      }
    }
  }
  // light bishop moves
  FOR_EACH_PIECE(piece_lists, light_bishop, square) {
    for (sq0x88_t target = start; target != stop; target += inc) {
      if (is_light_square(target) &&
          sliding_can_reach(chess_state, square, target,
                            bishop_increment(square, target))) {
        moves[move_count++] = move(square, target, QUIET_MOVE);
      }
    }
  }

  // dark bishop moves
  FOR_EACH_PIECE(piece_lists, dark_bishop, square) {
    for (sq0x88_t target = start; target != stop; target += inc) {
      if (is_dark_square(target) &&
          sliding_can_reach(chess_state, square, target,
                            bishop_increment(square, target))) {
        moves[move_count++] = move(square, target, QUIET_MOVE);
      }
    }
  }

  // knight moves
  FOR_EACH_PIECE(piece_lists, knight, square) {
    for (sq0x88_t target = start; target != stop; target += inc) {
      if (knight_increment(square, target)) {
        moves[move_count++] = move(square, target, QUIET_MOVE);
      }
    }
  }
  if (sq0x88_to_rank07(start) == backrank(colour) &&
      sq0x88_to_rank07(stop) == backrank(colour)) {
    return move_count;
  }
  // pawn moves
  sq0x88_t pawn_inc = pawn_push_increment(colour);
  piece_t friendly_pawn = PAWN | colour;
  for (sq0x88_t target = start; target != stop; target += inc) {
    sq0x88_t from;
    from = target - pawn_inc;
    if (!off_the_board(from) && piece(chess_state, from) == friendly_pawn) {
      moves[move_count++] = move(from, target, QUIET_MOVE);
    }
    from = target - 2 * pawn_inc;
    if (!off_the_board(from) && piece(chess_state, from) == friendly_pawn &&
        piece(chess_state, target - pawn_inc) == EMPTY &&
        pawn_can_double_push(from, colour)) {
      moves[move_count++] = move(from, target, DOUBLE_PAWN_PUSH);
    }
  }

  return move_count;
}

size_t generate_moves_check_internal(const chess_state_t* chess_state,
                                     move_t* moves, colour_t colour) {
  // if more than 1 attacker, only king moves
  // if only 1 attacker, capture of attacker, block of attacker, king moves
  size_t move_count = 0;
  const piece_list_t* piece_lists = get_piece_list(chess_state, colour);

  sq0x88_t king_square = piece_lists->king_square;

  move_count = king_moves(chess_state, moves, move_count, king_square, colour);

  if (is_double_check(chess_state)) {
    return move_count;
  }

  piece_t checking_piece = piece(chess_state, checking_square(chess_state));

  move_count = generate_captures_of(chess_state, moves, move_count, colour,
                                    checking_square(chess_state));
  move_count = generate_promotion_captures_of(
      chess_state, moves, move_count, colour, checking_square(chess_state));

  // if checking piece isn't a sliding piece cant be interposed
  if (!(checking_piece & (BISHOP | ROOK | QUEEN))) {
    return move_count;
  }

  sq0x88_t inc = queen_increment(king_square, checking_square(chess_state));
  move_count = generate_interposing_moves(chess_state, moves, move_count,
                                          colour, king_square + inc,
                                          checking_square(chess_state), inc);
  move_count = generate_promotion_interposing_moves(
      chess_state, moves, move_count, colour, king_square + inc,
      checking_square(chess_state), inc);

  return move_count;
}

size_t generate_captures_check_internal(const chess_state_t* chess_state,
                                        move_t* moves, colour_t colour) {
  // if more than 1 attacker, only king moves
  // if only 1 attacker, capture of attacker, block of attacker, king moves
  size_t move_count = 0;
  const piece_list_t* piece_lists = get_piece_list(chess_state, colour);

  sq0x88_t king_square = piece_lists->king_square;

  move_count =
      king_captures(chess_state, moves, move_count, king_square, colour);

  if (is_double_check(chess_state)) {
    return move_count;
  }

  move_count = generate_captures_of(chess_state, moves, move_count, colour,
                                    checking_square(chess_state));

  return move_count;
}

size_t generate_quiets_check_internal(const chess_state_t* chess_state,
                                      move_t* moves, colour_t colour) {
  // if more than 1 attacker, only king moves
  // if only 1 attacker, capture of attacker, block of attacker, king moves
  size_t move_count = 0;
  const piece_list_t* piece_lists = get_piece_list(chess_state, colour);

  sq0x88_t king_square = piece_lists->king_square;

  move_count = king_quiets(chess_state, moves, move_count, king_square);

  if (is_double_check(chess_state)) {
    return move_count;
  }

  piece_t checking_piece = piece(chess_state, checking_square(chess_state));
  // if checking piece isn't a sliding piece cant be interposed
  if (!(checking_piece & (BISHOP | ROOK | QUEEN))) {
    return move_count;
  }

  sq0x88_t inc = queen_increment(king_square, checking_square(chess_state));
  move_count = generate_interposing_moves(chess_state, moves, move_count,
                                          colour, king_square + inc,
                                          checking_square(chess_state), inc);

  return move_count;
}

size_t generate_promotions_check_internal(const chess_state_t* chess_state,
                                          move_t* moves, colour_t colour) {
  // if more than 1 attacker, only king moves
  // if only 1 attacker, capture of attacker, block of attacker, king moves
  size_t move_count = 0;
  const piece_list_t* piece_lists = get_piece_list(chess_state, colour);

  sq0x88_t king_square = piece_lists->king_square;

  if (is_double_check(chess_state)) {
    return move_count;
  }

  piece_t checking_piece = piece(chess_state, checking_square(chess_state));

  move_count = generate_promotion_captures_of(
      chess_state, moves, move_count, colour, checking_square(chess_state));

  // if checking piece isn't a sliding piece cant be interposed
  if (!(checking_piece & (BISHOP | ROOK | QUEEN))) {
    return move_count;
  }

  sq0x88_t inc = queen_increment(king_square, checking_square(chess_state));

  move_count = generate_promotion_interposing_moves(
      chess_state, moves, move_count, colour, king_square + inc,
      checking_square(chess_state), inc);

  return move_count;
}

size_t generate_moves(const chess_state_t* chess_state, move_t* moves,
                      colour_t colour) {
  size_t move_count;

  if (is_check(chess_state)) {
    move_count = generate_moves_check_internal(chess_state, moves, colour);
  } else {
    move_count = generate_moves_nocheck_internal(chess_state, moves, colour);
  }

  return move_count;
}

size_t generate_captures(const chess_state_t* chess_state, move_t* moves,
                         colour_t colour) {
  size_t move_count;

  if (is_check(chess_state)) {
    move_count = generate_captures_check_internal(chess_state, moves, colour);
  } else {
    move_count = generate_captures_nocheck_internal(chess_state, moves, colour);
  }

  return move_count;
}
size_t generate_quiets(const chess_state_t* chess_state, move_t* moves,
                       colour_t colour) {
  size_t move_count;

  if (is_check(chess_state)) {
    move_count = generate_quiets_check_internal(chess_state, moves, colour);
  } else {
    move_count = generate_quiets_nocheck_internal(chess_state, moves, colour);
  }

  return move_count;
}
size_t generate_promotions(const chess_state_t* chess_state, move_t* moves,
                           colour_t colour) {
  size_t move_count;

  if (is_check(chess_state)) {
    move_count = generate_promotions_check_internal(chess_state, moves, colour);
  } else {
    move_count =
        generate_promotions_nocheck_internal(chess_state, moves, colour);
  }

  return move_count;
}

size_t remove_illegal_moves(const chess_state_t* chess_state, move_t* moves,
                            size_t move_count) {
  for (size_t i = 0; i < move_count; i++) {
    if (!is_legal(chess_state, moves[i])) {
      moves[i--] = moves[--move_count];
    }
  }
  return move_count;
}

size_t generate_legal_moves(const chess_state_t* chess_state, move_t* moves,
                            colour_t colour) {
  return remove_illegal_moves(chess_state, moves,
                              generate_moves(chess_state, moves, colour));
}

size_t generate_legal_captures(const chess_state_t* chess_state, move_t* moves,
                               colour_t colour) {
  return remove_illegal_moves(chess_state, moves,
                              generate_captures(chess_state, moves, colour));
}

size_t generate_legal_quiets(const chess_state_t* chess_state, move_t* moves,
                             colour_t colour) {
  return remove_illegal_moves(chess_state, moves,
                              generate_quiets(chess_state, moves, colour));
}

size_t generate_legal_promotions(const chess_state_t* chess_state,
                                 move_t* moves, colour_t colour) {
  return remove_illegal_moves(chess_state, moves,
                              generate_promotions(chess_state, moves, colour));
}

// Expanded from src/chess/increment-vectors.c
#include <stdlib.h>


sq0x88_t queen_increment(sq0x88_t from, sq0x88_t to) {
  return queen_increment_vector[diff_0x88(to, from)];
}
sq0x88_t rook_increment(sq0x88_t from, sq0x88_t to) {
  return rook_increment_vector[diff_0x88(to, from)];
}
sq0x88_t bishop_increment(sq0x88_t from, sq0x88_t to) {
  return bishop_increment_vector[diff_0x88(to, from)];
}
sq0x88_t knight_increment(sq0x88_t from, sq0x88_t to) {
  return knight_increment_vector[diff_0x88(to, from)];
}
sq0x88_t king_increment(sq0x88_t from, sq0x88_t to) {
  return king_increment_vector[diff_0x88(to, from)];
}

sq0x88_t backwards_ray_cast(const chess_state_t* chess_state, sq0x88_t from,
                            sq0x88_t inc) {
  sq0x88_t next;
  for (next = from - inc; piece(chess_state, next) == EMPTY; next -= inc);
  return next;
}

sq0x88_t forwards_ray_cast(const chess_state_t* chess_state, sq0x88_t from,
                           sq0x88_t inc) {
  sq0x88_t next;
  for (next = from + inc; piece(chess_state, next) == EMPTY; next += inc);
  return next;
}
// Expanded from src/chess/game-over.c
#include <stdio.h>


int is_draw_by_repetition(const chess_state_t* chess_state) {
  if (chess_state->ply_counter - chess_state->ply_of_last_irreversible_move <
      5) {
    return 0;
  }
  zobrist_t current_zobrist = chess_state->zobrist;
  int repetitions = 1;
  for (int i = chess_state->ply_counter - 2;
       i >= chess_state->ply_of_last_irreversible_move && i > 1; i -= 2) {
    if (chess_state->ply_stack[i].zobrist == current_zobrist &&
        chess_state->ply_stack[i].rights == chess_state->castle_rights &&
        chess_state->ply_stack[i].enpassent == 0x88) {
      repetitions++;
    }

    if (chess_state->ply_stack[i].rights != chess_state->castle_rights) {
      break;
    }
    if (repetitions >= 3) {
      break;
    }
  }
  return repetitions >= 3;
}

int is_draw_by_insufficient_material(const chess_state_t* chess_state) {
  if (chess_state->black_pieces.pawn_count > 0 ||
      chess_state->white_pieces.pawn_count > 0 ||
      chess_state->black_pieces.rook_count > 0 ||
      chess_state->white_pieces.rook_count > 0 ||
      chess_state->black_pieces.queen_count > 0 ||
      chess_state->white_pieces.queen_count > 0 ||
      chess_state->white_pieces.knight_count +
              chess_state->white_pieces.dark_bishop_count +
              chess_state->white_pieces.light_bishop_count >
          1 ||
      chess_state->black_pieces.knight_count +
              chess_state->black_pieces.dark_bishop_count +
              chess_state->black_pieces.light_bishop_count >
          1) {
    return 0;
  }
  return 1;
}

int is_draw_by_50_move_rule(const chess_state_t* chess_state) {
  return chess_state->half_move_clock >= 100;
}

int is_draw(const chess_state_t* chess_state) {
  return is_draw_by_repetition(chess_state) ||
         is_draw_by_50_move_rule(chess_state) ||
         is_draw_by_insufficient_material(chess_state);
}

int is_checkmate(const chess_state_t* chess_state) {
  if (!is_check(chess_state)) return 0;
  move_t moves[256];
  size_t move_count =
      generate_moves(chess_state, moves, chess_state->friendly_colour);
  for (size_t i = 0; i < move_count; i++) {
    if (is_legal(chess_state, moves[i])) {
      return 0;
    }
  }
  return 1;
}

int is_stalemate(const chess_state_t* chess_state) {
  if (is_check(chess_state)) return 0;
  move_t moves[256];
  size_t move_count = castling_moves(chess_state, moves, 0,
                                     chess_state->friendly_pieces->king_square,
                                     chess_state->friendly_colour);
  for (size_t i = 0; i < move_count; i++) {
    if (is_legal(chess_state, moves[i])) {
      return 0;
    }
  }
  move_count = king_moves(chess_state, moves, 0,
                          chess_state->friendly_pieces->king_square,
                          chess_state->friendly_colour);
  for (size_t i = 0; i < move_count; i++) {
    if (is_legal(chess_state, moves[i])) {
      return 0;
    }
  }
  FOR_EACH_PIECE(chess_state->friendly_pieces, pawn, square) {
    size_t move_count =
        pawn_moves(chess_state, moves, 0, square, chess_state->friendly_colour);
    for (size_t i = 0; i < move_count; i++) {
      if (is_legal(chess_state, moves[i])) {
        return 0;
      }
    }
  }

  FOR_EACH_PIECE(chess_state->friendly_pieces, knight, square) {
    size_t move_count = knight_moves(chess_state, moves, 0, square,
                                     chess_state->friendly_colour);
    for (size_t i = 0; i < move_count; i++) {
      if (is_legal(chess_state, moves[i])) {
        return 0;
      }
    }
  }

  FOR_EACH_PIECE(chess_state->friendly_pieces, light_bishop, square) {
    size_t move_count = sliding_moves(
        chess_state, moves, 0, square, chess_state->friendly_colour,
        bishop_increments_list, BISHOP_INCREMENTS_COUNT);
    for (size_t i = 0; i < move_count; i++) {
      if (is_legal(chess_state, moves[i])) {
        return 0;
      }
    }
  }

  FOR_EACH_PIECE(chess_state->friendly_pieces, dark_bishop, square) {
    size_t move_count = sliding_moves(
        chess_state, moves, 0, square, chess_state->friendly_colour,
        bishop_increments_list, BISHOP_INCREMENTS_COUNT);
    for (size_t i = 0; i < move_count; i++) {
      if (is_legal(chess_state, moves[i])) {
        return 0;
      }
    }
  }

  FOR_EACH_PIECE(chess_state->friendly_pieces, rook, square) {
    size_t move_count = sliding_moves(
        chess_state, moves, 0, square, chess_state->friendly_colour,
        rook_increments_list, ROOK_INCREMENTS_COUNT);
    for (size_t i = 0; i < move_count; i++) {
      if (is_legal(chess_state, moves[i])) {
        return 0;
      }
    }
  }
  FOR_EACH_PIECE(chess_state->friendly_pieces, queen, square) {
    size_t move_count = sliding_moves(
        chess_state, moves, 0, square, chess_state->friendly_colour,
        queen_increments_list, QUEEN_INCREMENTS_COUNT);
    for (size_t i = 0; i < move_count; i++) {
      if (is_legal(chess_state, moves[i])) {
        return 0;
      }
    }
  }
  return 1;
}

enum gameover_state is_gameover(const chess_state_t* chess_state) {
  if (is_checkmate(chess_state)) {
    return CHECKMATE;
  }
  if (is_stalemate(chess_state)) {
    return STALEMATE;
  }
  if (is_draw_by_50_move_rule(chess_state)) {
    return DRAW_BY_50_MOVE_RULE;
  }
  if (is_draw_by_repetition(chess_state)) {
    return DRAW_BY_REPETITION;
  }
  if (is_draw_by_insufficient_material(chess_state)) {
    return DRAW_BY_INSUFFICIENT_MATERIAL;
  }
  return ONGOING;
}

colour_t get_winner(const chess_state_t* chess_state) {
  if (is_checkmate(chess_state)) {
    return chess_state->black_to_move ? WHITE : BLACK;
  }
  if (is_stalemate(chess_state) || is_draw(chess_state)) {
    return EMPTY;
  }
  return EMPTY;
}
// Expanded from src/chess/piece_list.c

#include <assert.h>
#include <stdio.h>


void remove_piece(chess_state_t* chess_state, sq0x88_t target) {
  piece_t piece = chess_state->board[target];
  chess_state->zobrist =
      zobrist_flip_piece(chess_state->zobrist, piece, target);

  piece_list_t* pl;

  if (piece & WHITE) {
    pl = &chess_state->white_pieces;
  } else if (piece & BLACK) {
    pl = &chess_state->black_pieces;
  } else {
    trace_ply_stack(chess_state);
    assert(0 && "piece has no colour");
    return;
  }

  uint8_t index = pl->indices_list[sq0x88_to_sq8x8(target)];
  uint8_t* piece_count;
  sq0x88_t* piece_list;

  switch (piece & PIECE_MASK) {
    case PAWN:
      piece_count = &pl->pawn_count;
      piece_list = pl->pawn_list;
      break;
    case KNIGHT:
      piece_count = &pl->knight_count;
      piece_list = pl->knight_list;
      break;
    case BISHOP:
      if (is_light_square(target)) {
        piece_count = &pl->light_bishop_count;
        piece_list = pl->light_bishop_list;
      } else {
        piece_count = &pl->dark_bishop_count;
        piece_list = pl->dark_bishop_list;
      }
      break;
    case ROOK:
      piece_count = &pl->rook_count;
      piece_list = pl->rook_list;
      break;
    case QUEEN:
      piece_count = &pl->queen_count;
      piece_list = pl->queen_list;
      break;
    default:
      trace_ply_stack(chess_state);
      assert(0 && "invalid piece code");
      break;
  }
  piece_list[index] = piece_list[--(*piece_count)];
  pl->indices_list[sq0x88_to_sq8x8(piece_list[index])] = index;
  chess_state->board[target] = EMPTY;
}

void place_piece(chess_state_t* chess_state, sq0x88_t target, piece_t piece) {
  chess_state->zobrist =
      zobrist_flip_piece(chess_state->zobrist, piece, target);
  piece_list_t* pl;
  if (piece & WHITE) {
    pl = &chess_state->white_pieces;
  } else if (piece & BLACK) {
    pl = &chess_state->black_pieces;
  } else {
    trace_ply_stack(chess_state);
    assert(0 && "piece has no colour");
    return;
  }
  if (piece & KING) {
    pl->king_square = target;
      chess_state->board[target] = piece;
      return;
  }

  sq0x88_t* piece_list;
  uint8_t* piece_count;
  switch (piece & PIECE_MASK) {
    case PAWN:
      piece_list = pl->pawn_list;
      piece_count = &pl->pawn_count;
      break;
    case KNIGHT:
       piece_list = pl->knight_list;
      piece_count = &pl->knight_count;
      break;
    case BISHOP:
      if (is_light_square(target)) {
         piece_list = pl->light_bishop_list;
         piece_count = &pl->light_bishop_count;
      } else {
         piece_list = pl->dark_bishop_list;
         piece_count = &pl->dark_bishop_count;
      }
      break;
    case ROOK:
       piece_list = pl->rook_list;
       piece_count = &pl->rook_count;
      break;
    case QUEEN:
       piece_list = pl->queen_list;
       piece_count = &pl->queen_count;
      break;
    default:
      assert(0 && "invalid piece code");
      break;
  }
  piece_list[*piece_count] = target;                       
  pl->indices_list[sq0x88_to_sq8x8(target)] = *piece_count; 
  (*piece_count)++;
  chess_state->board[target] = piece;
}

void move_piece(chess_state_t* chess_state, sq0x88_t from, sq0x88_t to) {
  piece_t piece = chess_state->board[from];
  chess_state->zobrist = zobrist_move_piece(chess_state->zobrist, piece, from, to);

  piece_list_t* pl;
  if (piece & WHITE) {
    pl = &chess_state->white_pieces;
  } else if (piece & BLACK) {
    pl = &chess_state->black_pieces;
  } else {
    trace_ply_stack(chess_state);
    assert(0 && "piece has no colour");
    return;
  }
  if ((piece & PIECE_MASK) == KING) {
    pl->king_square = to;
    chess_state->board[to] = piece;
    chess_state->board[from] = EMPTY;
    return;
  }
  int index = pl->indices_list[sq0x88_to_sq8x8(from)];
  pl->indices_list[sq0x88_to_sq8x8(to)] = index;
  switch (piece & PIECE_MASK) {
    case PAWN:
      pl->pawn_list[index] = to;
      break;
    case KNIGHT:
      pl->knight_list[index] = to;
      break;
    case BISHOP:
      if (is_light_square(from)) {
        pl->light_bishop_list[index] = to;
      } else {
        pl->dark_bishop_list[index] = to;
      }
      break;
    case ROOK:
      pl->rook_list[index] = to;
      break;
    case QUEEN:
      pl->queen_list[index] = to;
      break;
    default:
      assert(0 && "invalid piece code");
      break;
  }

  chess_state->board[to] = piece;
  chess_state->board[from] = EMPTY;
}

// Expanded from src/chess/make_move.c
// #include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


void push_ply_stack(chess_state_t* chess_state, move_t move) {
  if (chess_state->ply_counter >= chess_state->ply_stack_capacity) {
    chess_state->ply_stack_capacity = chess_state->ply_stack_capacity * 2;
    size_t ply_stack_size =
        sizeof(ply_stack_item_t) * chess_state->ply_stack_capacity;
    chess_state->ply_stack = realloc(chess_state->ply_stack, ply_stack_size);
  }
  chess_state->ply_stack[chess_state->ply_counter++] = (ply_stack_item_t){
      .move = move,
      .enpassent = chess_state->enpassent_target,
      .half_move_clock = chess_state->half_move_clock,
      .rights = chess_state->castle_rights,
      .captured = piece(chess_state, get_to(move)),
      .zobrist = chess_state->zobrist,
      .check_square = chess_state->check_square,
      .n_checks = chess_state->n_checks,
      .discovered_check = chess_state->discovered_check,
      .last_irreversible = chess_state->ply_of_last_irreversible_move,
  };
}

void update_board(chess_state_t* chess_state, move_t move) {
  sq0x88_t from = get_from(move);
  sq0x88_t to = get_to(move);

  if (is_enpassent(move)) {
    remove_piece(chess_state,
                 chess_state->enpassent_target - chess_state->up_increment);
  } else if (is_capture(move)) {
    remove_piece(chess_state, to);
  }

  if (!is_promotion(move)) {
    //  move piece
    move_piece(chess_state, from, to);

  } else {
    remove_piece(chess_state, from);
    place_piece(chess_state, to,
                get_promotes_to(move) | chess_state->friendly_colour);
  }

  if (is_king_castle(move)) {
    move_piece(chess_state, from + 3, to - 1);
  }
  if (is_queen_castle(move)) {
    move_piece(chess_state, from - 4, to + 1);
  }
}

void update_rights(chess_state_t* chess_state, move_t move) {
  sq0x88_t from = get_from(move);
  sq0x88_t to = get_to(move);
  // castle rights
  if (from == A1 || to == A1) {
    chess_state->castle_rights &= ~WHITE_QUEEN_SIDE;
  }
  if (from == H1 || to == H1) {
    chess_state->castle_rights &= ~WHITE_KING_SIDE;
  }
  if (from == A8 || to == A8) {
    chess_state->castle_rights &= ~BLACK_QUEEN_SIDE;
  }
  if (from == H8 || to == H8) {
    chess_state->castle_rights &= ~BLACK_KING_SIDE;
  }
  if (from == E1) {
    chess_state->castle_rights &= ~WHITE_BOTH_SIDES;
  }
  if (from == E8) {
    chess_state->castle_rights &= ~BLACK_BOTH_SIDES;
  }
}

void update_enpassent_target(chess_state_t* chess_state, move_t move) {
  if (get_flags(move) == DOUBLE_PAWN_PUSH) {
    chess_state->enpassent_target = get_from(move) + chess_state->up_increment;
  } else {
    chess_state->enpassent_target = 0x88;
  }
}

void update_half_move_clock(chess_state_t* chess_state, move_t move) {
  if (piece(chess_state, get_from(move)) & PAWN || is_capture(move)) {
    chess_state->ply_of_last_irreversible_move = chess_state->ply_counter;
    chess_state->half_move_clock = 0;
  } else {
    chess_state->half_move_clock++;
  }
}

#define SWAP(type, lhs, rhs) \
  {                          \
    type temp = (lhs);       \
    (lhs) = (rhs);           \
    (rhs) = temp;            \
  }

void update_turn(chess_state_t* chess_state) {
  chess_state->black_to_move = !chess_state->black_to_move;
  chess_state->zobrist = zobrist_flip_turn(chess_state->zobrist);
  SWAP(colour_t, chess_state->friendly_colour, chess_state->enemy_colour);
  SWAP(piece_list_t*, chess_state->friendly_pieces, chess_state->enemy_pieces);
  SWAP(sq0x88_t, chess_state->up_increment, chess_state->down_increment);
}

void make_move(chess_state_t* chess_state, move_t move) {
  if (is_null_move(move)) {
    push_ply_stack(chess_state, move);
    update_half_move_clock(chess_state, move);
    update_enpassent_target(chess_state, move);
    update_turn(chess_state);
    return;
  }
#ifdef DEBUG
  if (piece(chess_state, move.to) & KING) {
    trace_ply_stack(chess_state);
    printf("illegal move detected (captures king)");
    abort();
  }
  if (piece_is_friendly(chess_state, move.to)) {
    trace_ply_stack(chess_state);
    printf("illegal move detected (captures friendly)");
    abort();
  }
  if (off_the_board(move.from) || off_the_board(move.to)) {
    trace_ply_stack(chess_state);
    printf("illegal move detected (off the board)");
    abort();
  }
#endif
  push_ply_stack(chess_state, move);
  update_half_move_clock(chess_state, move);
  update_board(chess_state, move);
  update_enpassent_target(chess_state, move);
  update_rights(chess_state, move);
  update_turn(chess_state);
  update_check(chess_state, move);
}

// restores the board to the state before the previous move was made
void unmake_move(chess_state_t* chess_state) {
  ply_stack_item_t unwound_state =
      chess_state->ply_stack[--chess_state->ply_counter];

  chess_state->check_square = unwound_state.check_square;
  chess_state->discovered_check = unwound_state.discovered_check;
  chess_state->n_checks = unwound_state.n_checks;
  chess_state->enpassent_target = unwound_state.enpassent;
  chess_state->castle_rights = unwound_state.rights;
  chess_state->half_move_clock = unwound_state.half_move_clock;
  chess_state->ply_of_last_irreversible_move = unwound_state.last_irreversible;

  move_t prev_move = unwound_state.move;
  piece_t captured_piece = unwound_state.captured;

  update_turn(chess_state);

  sq0x88_t from = get_from(prev_move);
  sq0x88_t to = get_to(prev_move);

  if (is_promotion(prev_move)) {
    remove_piece(chess_state, to);
    place_piece(chess_state, from, chess_state->friendly_colour | PAWN);
  } else {
    move_piece(chess_state, to, from);
  }

  if (is_enpassent(prev_move)) {
    place_piece(chess_state,
                chess_state->enpassent_target - chess_state->up_increment,
                chess_state->enemy_colour | PAWN);
  } else if (is_capture(prev_move)) {
    place_piece(chess_state, to, captured_piece);
  }

  if (is_king_castle(prev_move)) {
    move_piece(chess_state, to - 1, from + 3);
  }
  if (is_queen_castle(prev_move)) {
    move_piece(chess_state, to + 1, from - 4);
  }
}

// Expanded from src/chess/notation.c
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#ifdef DEBUG
#define PRINT_READ_ERRORS
#define PRINT_WRITE_ERRORS
#endif

#ifdef PRINT_READ_ERRORS
#define READ_ERROR(msg, ...)                                \
  {                                                         \
    fprintf(stderr, "READ ERROR: reading \"%s\" ", buffer); \
    fprintf(stderr, msg, ##__VA_ARGS__);                    \
    return -1;                                              \
  }
#else
#define READ_ERROR(msg, ...) \
  { return -1; }
#endif

#ifdef PRINT_WRITE_ERRORS
#define WRITE_ERROR(msg, ...)         \
  {                                   \
    fprintf(stderr, "WRITE ERROR: "); \
    printf(msg, ##__VA_ARGS__);       \
    buffer[0] = 0;                    \
    return -1;                        \
  }
#else
#define WRITE_ERROR(msg, ...) \
  {                           \
    buffer[0] = 0;            \
    return -1;                \
  }
#endif

int is_file(char c) { return c >= 'a' && c <= 'h'; }

int is_rank(char c) { return c >= '1' && c <= '8'; }

long write_square(char* buffer, long buffer_size, sq0x88_t square) {
  if (buffer_size < 3) return -1;
  if (off_the_board(square)) {
    WRITE_ERROR("square is off the board, square HEX value: \'%02x\'.\n",
                square);
  }
  buffer[0] = sq0x88_to_file07(square) + 'a';
  buffer[1] = sq0x88_to_rank07(square) + '1';
  buffer[2] = '\0';
  return 2;
}
long read_square(const char* buffer, long buffer_size, sq0x88_t* square) {
  if (buffer_size < 2) return -1;
  int file = buffer[0];
  int rank = buffer[1];
  if (!is_file(file)) {
    READ_ERROR("letter \'%c\' is not a valid file\n", file);
  }
  if (!is_rank(rank)) {
    READ_ERROR("letter \'%c\' is not a valid rank\n", rank);
  }
  *square = rankfile_to_sq0x88(rank - '1', file - 'a');
  return 2;
}

long write_piece(char* buffer, long buffer_size, piece_t piece) {
  if (buffer_size < 2) return -1;
  char piece_char;
  switch (piece & PIECE_MASK) {
    case KING:
      piece_char = 'K';
      break;
    case QUEEN:
      piece_char = 'Q';
      break;
    case ROOK:
      piece_char = 'R';
      break;
    case BISHOP:
      piece_char = 'B';
      break;
    case KNIGHT:
      piece_char = 'N';
      break;
    case PAWN:
      piece_char = 'P';
      break;
    default:
      WRITE_ERROR("invalid piece type %02x\n.", piece);
  }
  buffer[0] = piece_char;
  buffer[1] = '\0';
  return 1;
}

long read_piece(const char* buffer, long buffer_size, piece_t* piece) {
  *piece = EMPTY;
  if (buffer_size < 1) return -1;
  char piece_char = buffer[0];
  switch (piece_char) {
    case 'P':
      *piece = PAWN;
      break;
    case 'N':
      *piece = KNIGHT;
      break;
    case 'B':
      *piece = BISHOP;
      break;
    case 'R':
      *piece = ROOK;
      break;
    case 'Q':
      *piece = QUEEN;
      break;
    default:
      READ_ERROR("letter \'%c\' is not a valid piece.\n", piece_char)
  }
  return 1;
}

void disambiguate_piece(chess_state_t* chess_state, sq0x88_t from, sq0x88_t to,
                        sq0x88_t* piece_list, int piece_count,
                        sq0x88_t (*increment_func)(sq0x88_t, sq0x88_t),
                        int* disambiguate_rank, int* disambiguate_file) {
  for (int i = 0; i < piece_count; i++) {
    sq0x88_t sq = piece_list[i];
    if (sq == from) continue;
    sq0x88_t inc = increment_func(sq, to);
    if (inc && backwards_ray_cast(chess_state, to, inc) == sq &&
        is_legal(chess_state, move(sq, to, QUIET_MOVE))) {
      if (sq0x88_to_file07(from) == sq0x88_to_file07(sq))
        *disambiguate_rank = 1;
      else if (sq0x88_to_rank07(from) == sq0x88_to_rank07(sq))
        *disambiguate_file = 1;
      else if (*disambiguate_file != 0)
        *disambiguate_rank = 1;
      else
        *disambiguate_file = 1;
    }
  }
}

void disambiguate_knight(chess_state_t* chess_state, sq0x88_t from, sq0x88_t to,
                         int* disambiguate_rank, int* disambiguate_file) {
  for (int i = 0; i < chess_state->friendly_pieces->knight_count; i++) {
    sq0x88_t knight_square = chess_state->friendly_pieces->knight_list[i];
    if (knight_square == from) continue;
    if (knight_increment(knight_square, to) != 0 &&
        is_legal(chess_state, move(knight_square, to, QUIET_MOVE))) {
      if (sq0x88_to_file07(from) == sq0x88_to_file07(knight_square))
        *disambiguate_rank = 1;
      else if (sq0x88_to_rank07(from) == sq0x88_to_rank07(knight_square))
        *disambiguate_file = 1;
      else if (*disambiguate_file != 0)
        *disambiguate_rank = 1;
      else
        *disambiguate_file = 1;
    }
  }
}

long write_algebraic_notation(char* buffer, long buffer_size,
                              chess_state_t* chess_state,
                              move_t move_to_write) {
  // castling
  if (is_king_castle(move_to_write)) {
    if (buffer_size < 4) return -1;
    buffer[0] = 'O';
    buffer[1] = '-';
    buffer[2] = 'O';
    buffer[3] = '\0';
    return 3;
  }
  if (is_queen_castle(move_to_write)) {
    if (buffer_size < 6) return -1;
    buffer[0] = 'O';
    buffer[1] = '-';
    buffer[2] = 'O';
    buffer[3] = '-';
    buffer[4] = 'O';
    buffer[5] = '\0';
    return 5;
  }
  long out, bytes_written = 0;

  // piece character
  piece_t moved_piece = piece(chess_state, get_from(move_to_write));

  if ((moved_piece & PIECE_MASK) != PAWN) {
    out = write_piece(buffer + bytes_written, buffer_size - bytes_written,
                      moved_piece);
    if (out == -1) {
      buffer[0] = '\0';
      return -1;
    }
    bytes_written += out;
  }
  // disambiguation

  sq0x88_t from = get_from(move_to_write);
  sq0x88_t to = get_to(move_to_write);
  int disambiguate_rank = 0, disambiguate_file = 0;

  switch (moved_piece & PIECE_MASK) {
    case PAWN: {
      if (!is_capture(move_to_write))
        break;  // non capture pawn moves don't need disambiguation
      disambiguate_file = 1;  // always disambiguate pawn captures
    } break;
    case KNIGHT: {
      disambiguate_knight(chess_state, from, to, &disambiguate_rank,
                          &disambiguate_file);
    } break;
    case BISHOP: {
      if (is_light_square(to)) {
        disambiguate_piece(chess_state, from, to,
                           chess_state->friendly_pieces->light_bishop_list,
                           chess_state->friendly_pieces->light_bishop_count,
                           bishop_increment, &disambiguate_rank,
                           &disambiguate_file);
      } else {
        disambiguate_piece(chess_state, from, to,
                           chess_state->friendly_pieces->dark_bishop_list,
                           chess_state->friendly_pieces->dark_bishop_count,
                           bishop_increment, &disambiguate_rank,
                           &disambiguate_file);
      }
    } break;
    case ROOK: {
      disambiguate_piece(
          chess_state, from, to, chess_state->friendly_pieces->rook_list,
          chess_state->friendly_pieces->rook_count, rook_increment,
          &disambiguate_rank, &disambiguate_file);
    } break;
    case QUEEN: {
      disambiguate_piece(
          chess_state, from, to, chess_state->friendly_pieces->queen_list,
          chess_state->friendly_pieces->queen_count, queen_increment,
          &disambiguate_rank, &disambiguate_file);
    } break;
    case KING:
      break;  // no need to disambiguate king moves
    default: {
      buffer[0] = '\0';
      return -1;
    }  // invalid piece (probably already caught in previous step)
  }
  if (disambiguate_file) {
    if (buffer_size - bytes_written < 2)
      WRITE_ERROR("insufficient space in buffer.\n");
    buffer[bytes_written++] = sq0x88_to_file07(from) + 'a';
    buffer[bytes_written] = '\0';
  }
  if (disambiguate_rank) {
    if (buffer_size - bytes_written < 2)
      WRITE_ERROR("insufficient space in buffer.\n");
    buffer[bytes_written++] = sq0x88_to_rank07(from) + '1';
    buffer[bytes_written] = '\0';
  }

  // capture
  if (is_capture(move_to_write)) {
    if (buffer_size - bytes_written < 2)
      WRITE_ERROR("insufficient space in buffer.\n");
    buffer[bytes_written++] = 'x';
    buffer[bytes_written] = '\0';
  }

  // to square
  out = write_square(buffer + bytes_written, buffer_size - bytes_written,
                     get_to(move_to_write));
  if (out == -1) WRITE_ERROR("insufficient space in buffer.\n");
  bytes_written += out;

  // promotion
  if (is_promotion(move_to_write)) {
    if (buffer_size - bytes_written < 2)
      WRITE_ERROR("insufficient space in buffer.\n");
    buffer[bytes_written++] = '=';
    buffer[bytes_written] = '\0';
    out = write_piece(buffer + bytes_written, buffer_size - bytes_written,
                      get_promotes_to(move_to_write));
    if (out == -1) {
      buffer[0] = '\0';
      return -1;
    }
    bytes_written += out;
  }

  // check and checkmate
  int check = 0, checkmate = 0;
  if (!is_legal(chess_state, move_to_write))
    WRITE_ERROR("move to write is not legal.\n");
  make_move(chess_state, move_to_write);
  check = is_check(chess_state);
  checkmate = is_checkmate(chess_state);
  unmake_move(chess_state);

  if (checkmate) {
    if (buffer_size - bytes_written < 2)
      WRITE_ERROR("insufficient space in buffer.\n");
    buffer[bytes_written++] = '#';
  } else if (check) {
    if (buffer_size - bytes_written < 2)
      WRITE_ERROR("insufficient space in buffer.\n");
    buffer[bytes_written++] = '+';
  }

  // termination
  buffer[bytes_written] = '\0';
  return bytes_written;
}

int matches_disambiguation(sq0x88_t square, int rank, int file) {
  return (rank == -1 || sq0x88_to_rank07(square) == rank) &&
         (file == -1 || sq0x88_to_file07(square) == file);
}

long read_algebraic_notation(const char* buffer, long buffer_size,
                             const chess_state_t* chess_state,
                             move_t* read_move) {
  if (buffer_size == 0) {
    READ_ERROR("cannot parse empty buffer.\n");
  }

  long bytes_read = 0;

  *read_move = null_move;

  if (buffer_size >= 5 && strncmp(buffer, "O-O-O", 5) == 0) {
    if (!can_castle_queen_side(chess_state, chess_state->friendly_colour) ||
        !is_legal(chess_state,
                  move(chess_state->friendly_pieces->king_square,
                       chess_state->friendly_pieces->king_square - 2,
                       QUEEN_CASTLE))) {
      READ_ERROR("cannot legally castle queen side.\n");
    }
    *read_move =
        move(chess_state->friendly_pieces->king_square,
             chess_state->friendly_pieces->king_square - 2, QUEEN_CASTLE);
    return 5;
  }
  if (buffer_size >= 3 && strncmp(buffer, "O-O", 3) == 0) {
    if (!can_castle_king_side(chess_state, chess_state->friendly_colour) ||
        !is_legal(
            chess_state,
            move(chess_state->friendly_pieces->king_square,
                 chess_state->friendly_pieces->king_square + 2, KING_CASTLE))) {
      READ_ERROR("cannot legally castle king side.\n");
    }
    *read_move =
        move(chess_state->friendly_pieces->king_square,
             chess_state->friendly_pieces->king_square + 2, KING_CASTLE);
    return 3;
  }

  sq0x88_t from = -1, to = -1;
  int flags = 0;

  piece_t moved_piece = PAWN;
  char piece_char = buffer[bytes_read];
  if (isupper(piece_char)) {
    switch (piece_char) {
      case 'K':
        moved_piece = KING;
        break;
      case 'Q':
        moved_piece = QUEEN;
        break;
      case 'R':
        moved_piece = ROOK;
        break;
      case 'B':
        moved_piece = BISHOP;
        break;
      case 'N':
        moved_piece = KNIGHT;
        break;
      default:
        READ_ERROR("the letter \'%c\' is not a valid piece.\n", piece_char);
    }
    bytes_read++;
  }

  int disambiguation_rank = -1, disambiguation_file = -1;
  int to_square_rank = -1, to_square_file = -1;
  if (bytes_read < buffer_size && is_file(buffer[bytes_read])) {
    disambiguation_file = buffer[bytes_read] - 'a';
    bytes_read++;
  }
  if (bytes_read < buffer_size && is_rank(buffer[bytes_read])) {
    disambiguation_rank = buffer[bytes_read] - '1';
    bytes_read++;
  }
  if (bytes_read < buffer_size && buffer[bytes_read] == 'x') {
    flags |= CAPTURE;
    bytes_read++;
  }
  if (bytes_read < buffer_size && is_file(buffer[bytes_read])) {
    to_square_file = buffer[bytes_read] - 'a';
    bytes_read++;
  }
  if (bytes_read < buffer_size && is_rank(buffer[bytes_read])) {
    to_square_rank = buffer[bytes_read] - '1';
    bytes_read++;
  }

  int from_rank = -1;
  int from_file = -1;

  if (disambiguation_file != -1 && disambiguation_rank != -1 &&
      to_square_file == -1 && to_square_rank == -1) {
    to = rankfile_to_sq0x88(disambiguation_rank, disambiguation_file);
  } else if (to_square_file != -1 && to_square_rank != -1) {
    to = rankfile_to_sq0x88(to_square_rank, to_square_file);
    from_rank = disambiguation_rank;
    from_file = disambiguation_file;
  } else {
    READ_ERROR("move missing valid destination square.\n");
  }

  if (piece_is_friendly(chess_state, to)) {
    READ_ERROR("move is illegal (attempting to capture own piece).\n");
  }

  int found_valid_pieces = 0;

  switch (moved_piece & PIECE_MASK) {
    case PAWN: {
      for (int i = 0; i < chess_state->friendly_pieces->pawn_count; i++) {
        sq0x88_t pawn_square = chess_state->friendly_pieces->pawn_list[i];
        // doesn't match disambiguations from move
        if (!matches_disambiguation(pawn_square, from_rank, from_file)) {
          continue;
        }
        if ((sq0x88_t)(pawn_square + chess_state->up_increment) == to &&
            piece(chess_state, to) == EMPTY &&
            is_legal(chess_state, move(pawn_square, to, QUIET_MOVE))) {
          found_valid_pieces++;
          from = pawn_square;
        }
        if ((sq0x88_t)(pawn_square + chess_state->up_increment * 2) == to &&
            piece(chess_state, to) == EMPTY &&
            piece(chess_state, pawn_square + chess_state->up_increment) ==
                EMPTY &&
            is_legal(chess_state, move(pawn_square, to, DOUBLE_PAWN_PUSH))) {
          found_valid_pieces++;
          from = pawn_square;
          flags = DOUBLE_PAWN_PUSH;
        }
        int test_move_flag =
            (to == enpassent_target(chess_state)) ? ENPASSENT : CAPTURE;
        if ((sq0x88_t)(pawn_square + 1 + chess_state->up_increment) == to &&
            (piece_is_enemy(chess_state, to) || test_move_flag == ENPASSENT) &&
            is_legal(chess_state, move(pawn_square, to, test_move_flag))) {
          found_valid_pieces++;
          from = pawn_square;
          flags = test_move_flag;
        }
        if ((sq0x88_t)(pawn_square - 1 + chess_state->up_increment) == to &&
            (piece_is_enemy(chess_state, to) || test_move_flag == ENPASSENT) &&
            is_legal(chess_state, move(pawn_square, to, test_move_flag))) {
          found_valid_pieces++;
          from = pawn_square;
          flags = test_move_flag;
        }
      }
    } break;
    case KNIGHT: {
      for (int i = 0; i < chess_state->friendly_pieces->knight_count; i++) {
        sq0x88_t knight_square = chess_state->friendly_pieces->knight_list[i];
        // doesn't match disambiguations from move
        if (!matches_disambiguation(knight_square, from_rank, from_file)) {
          continue;
        }
        // knight can legally reach to square
        if (knight_increment(knight_square, to) != 0 &&
            is_legal(chess_state, move(knight_square, to, QUIET_MOVE))) {
          found_valid_pieces++;
          from = knight_square;
        }
      }
    } break;
    case BISHOP: {
      sq0x88_t* piece_list;
      int piece_count;
      if (is_light_square(to)) {
        piece_list = chess_state->friendly_pieces->light_bishop_list;
        piece_count = chess_state->friendly_pieces->light_bishop_count;
      } else {
        piece_list = chess_state->friendly_pieces->dark_bishop_list;
        piece_count = chess_state->friendly_pieces->dark_bishop_count;
      }

      for (int i = 0; i < piece_count; i++) {
        sq0x88_t bishop_square = piece_list[i];
        // doesn't match disambiguations from move
        if (!matches_disambiguation(bishop_square, from_rank, from_file)) {
          continue;
        }
        // bishop can legally reach to square
        int inc = bishop_increment(bishop_square, to);
        if (inc && backwards_ray_cast(chess_state, to, inc) == bishop_square &&
            is_legal(chess_state, move(bishop_square, to, QUIET_MOVE))) {
          found_valid_pieces++;
          from = bishop_square;
        }
      }

    } break;
    case ROOK: {
      for (int i = 0; i < chess_state->friendly_pieces->rook_count; i++) {
        sq0x88_t rook_square = chess_state->friendly_pieces->rook_list[i];
        // doesn't match disambiguations from move
        if (!matches_disambiguation(rook_square, from_rank, from_file)) {
          continue;
        }
        // rook can legally reach to square
        int inc = rook_increment(rook_square, to);
        if (inc && backwards_ray_cast(chess_state, to, inc) == rook_square &&
            is_legal(chess_state, move(rook_square, to, QUIET_MOVE))) {
          found_valid_pieces++;
          from = rook_square;
        }
      }
    } break;
    case QUEEN: {
      for (int i = 0; i < chess_state->friendly_pieces->queen_count; i++) {
        sq0x88_t queen_square = chess_state->friendly_pieces->queen_list[i];
        // doesn't match disambiguations from move
        if (!matches_disambiguation(queen_square, from_rank, from_file)) {
          continue;
        }
        // queen can legally reach to square
        int inc = queen_increment(queen_square, to);
        if (inc && backwards_ray_cast(chess_state, to, inc) == queen_square &&
            is_legal(chess_state, move(queen_square, to, QUIET_MOVE))) {
          found_valid_pieces++;
          from = queen_square;
        }
      }
    } break;
    case KING: {
      from = chess_state->friendly_pieces->king_square;
      found_valid_pieces = 1;
      if (king_increment(from, to) == 0 ||
          !is_legal(chess_state, move(from, to, QUIET_MOVE)))
        return -1;
    } break;
    default:
      return -1;
  }

  if (found_valid_pieces == 0) {
    READ_ERROR("no piece which can legally reach this square.\n");
  }
  if (found_valid_pieces > 1) {
    READ_ERROR("multiple pieces can legally reach this square.\n");
  }

  // promotion
  if (bytes_read < buffer_size && buffer[bytes_read] == '=') {
    if (moved_piece != PAWN && sq0x88_to_rank07(to) != 0 &&
        sq0x88_to_rank07(to) != 7) {
      READ_ERROR("illegal promotion.\n");
    }
    flags |= PROMOTION;
    bytes_read++;
    if (bytes_read >= buffer_size) return -1;
    switch (buffer[bytes_read]) {
      case 'Q':
        flags |= QUEEN_PROMOTE_TO;
        break;
      case 'R':
        flags |= ROOK_PROMOTE_TO;
        break;
      case 'B':
        flags |= BISHOP_PROMOTE_TO;
        break;
      case 'N':
        flags |= KNIGHT_PROMOTE_TO;
        break;
      default:
        READ_ERROR("the letter \'%c\' is not a valid promotion.\n",
                   buffer[bytes_read]);
    }
    bytes_read++;
  }
  // skip check and checkmate
  if (bytes_read < buffer_size && buffer[bytes_read] == '+') {
    bytes_read++;
  } else if (bytes_read < buffer_size && buffer[bytes_read] == '#') {
    bytes_read++;
  }

  // unexpected characters at end of move
  if (bytes_read < buffer_size && buffer[bytes_read] != ' ' &&
      buffer[bytes_read] != '\t' && buffer[bytes_read] != '\n' &&
      buffer[bytes_read] != '\r' && buffer[bytes_read] != '\0') {
    READ_ERROR("unexpected letters after end of move.\n");
  }

  // set move
  move_t move_to_test = move(from, to, flags);
  if (!is_legal(chess_state, move_to_test))
    READ_ERROR("read move is not legal.\n");
  *read_move = move_to_test;
  return bytes_read;
}

long write_long_algebraic_notation(char* buffer, long buffer_size,
                                   move_t move) {
  long bytes_read = 0, out;

  if (buffer_size < 5) WRITE_ERROR("insufficient space in buffer.\n");

  if (is_null_move(move)) {
    buffer[0] = '0';
    buffer[1] = '0';
    buffer[2] = '0';
    buffer[3] = '0';
    buffer[4] = '\0';
    return 4;
  }

  // write from square
  out = write_square(buffer + bytes_read, buffer_size - bytes_read, move.from);
  if (out == -1) {
    buffer[0] = '\0';
    return -1;
  }
  bytes_read += out;

  // write to square
  out = write_square(buffer + bytes_read, buffer_size - bytes_read, move.to);
  if (out == -1) {
    buffer[0] = '\0';
    return -1;
  }
  bytes_read += out;

  // write promotion
  if (is_promotion(move)) {
    out = write_piece(buffer + bytes_read, buffer_size - bytes_read,
                      get_promotes_to(move));
    if (out == -1) {
      buffer[0] = '\0';
      return -1;
    }
    bytes_read += out;
  }
  return bytes_read;
}

// @todo add validation
long read_long_algebraic_notation(const char* buffer, long buffer_size,
                                  const chess_state_t* chess_state,
                                  move_t* read_move) {
  long bytes_read = 0, out;
  sq0x88_t from, to;
  piece_t promotion;
  int move_flags = QUIET_MOVE;

  *read_move = null_move;  // default to null_move

  if (buffer_size >= 4 && strncmp(buffer, "0000", 4) == 0) {
    return 4;
  }

  // read from square
  out = read_square(buffer + bytes_read, buffer_size - bytes_read, &from);
  if (out == -1) return -1;
  bytes_read += out;

  // read to square
  out = read_square(buffer + bytes_read, buffer_size - bytes_read, &to);
  if (out == -1) return -1;
  bytes_read += out;
  if (piece(chess_state, to) != EMPTY) {
    move_flags |= CAPTURE;
  }
  // calculate move flags
  if (piece(chess_state, from) & PAWN) {
    if (to == enpassent_target(chess_state)) {
      move_flags = ENPASSENT;
    }
    if ((sq0x88_t)(to - from) ==
        (sq0x88_t)(pawn_push_increment(chess_state->friendly_colour) * 2)) {
      move_flags = DOUBLE_PAWN_PUSH;
    }
    if (sq0x88_to_rank07(to) == 7 || sq0x88_to_rank07(to) == 0) {
      move_flags |= PROMOTION;
      // read promotion
      out =
          read_piece(buffer + bytes_read, buffer_size - bytes_read, &promotion);
      if (out == -1) return -1;
      bytes_read += out;

      switch (promotion) {
        case QUEEN:
          move_flags |= QUEEN_PROMOTE_TO;
          break;
        case ROOK:
          move_flags |= ROOK_PROMOTE_TO;
          break;
        case BISHOP:
          move_flags |= BISHOP_PROMOTE_TO;
          break;
        case KNIGHT:
          move_flags |= KNIGHT_PROMOTE_TO;
          break;
        default:
          READ_ERROR("invalid promotion target\n")
      }
    }
  } else if (piece(chess_state, from) & KING) {
    if ((sq0x88_t)(from - to) == (sq0x88_t)(-2)) {
      move_flags = KING_CASTLE;
    }
    if ((sq0x88_t)(from - to) == (sq0x88_t)(2)) {
      move_flags = QUEEN_CASTLE;
    }
  }
  *read_move = move(from, to, move_flags);
  return bytes_read;
}

long write_movetext_debug(char* buffer, long buffer_size,
                          const chess_state_t* chess_state) {
  long bytes_written = 0, out;
  for (int i = 0; i < chess_state->ply_counter; i++) {
    move_t move = chess_state->ply_stack[i].move;
    out = write_long_algebraic_notation(buffer + bytes_written,
                                        buffer_size - bytes_written, move);
    if (out == -1) break;
    bytes_written += out;
    if (bytes_written < buffer_size) {
      buffer[bytes_written++] = ' ';
    }
  }
  return bytes_written;
}

long write_movetext(char* buffer, long buffer_size,
                    const chess_state_t* chess_state,
                    const char* start_position) {
  long bytes_written = 0, out;
  chess_state_t state = {0};
  if (start_position == NULL) {
    load_start_position(&state);
  } else {
    load_position(&state, start_position);
  }
  for (int i = 0; i < chess_state->ply_counter; i++) {
    move_t move = chess_state->ply_stack[i].move;
    out = write_algebraic_notation(buffer + bytes_written,
                                   buffer_size - bytes_written, &state, move);
    make_move(&state, move);
    if (out == -1) break;
    bytes_written += out;

    if (bytes_written < buffer_size) {
      buffer[bytes_written++] = ' ';
    }
  }
  free(state.ply_stack);
  return bytes_written;
}

long write_pgn(char* buffer, long buffer_size,
               const chess_state_t* chess_state, const char* event,
               const char* site, const char* date, const char* round,
               const char* white_name, const char* black_name,
               const char* fen) {
  const char* result = "*";
  if (is_draw(chess_state) || is_stalemate(chess_state)) {
    result = "1/2-1/2";
  } else if (is_checkmate(chess_state)) {
    if (chess_state->black_to_move) {
      result = "1-0";
    } else {
      result = "0-1";
    }
  }

  if (event == NULL) event = "?";
  if (site == NULL) site = "?";
  if (date == NULL) date = "????.??.??";
  if (round == NULL) round = "?";

  long bytes_written = 0;
  bytes_written +=
      snprintf(buffer + bytes_written, buffer_size - bytes_written,
               "[Event \"%s\"]\n"
               "[Site \"%s\"]\n"
               "[Date \"%s\"]\n"
               "[Round \"%s\"]\n"
               "[White \"%s\"]\n"
               "[Black \"%s\"]\n"
               "[Result \"%s\"]\n",
               event, site, date, round, white_name, black_name, result);
  if (fen != NULL) {
    bytes_written +=
        snprintf(buffer + bytes_written, buffer_size - bytes_written,
                 "[FEN \"%s\"]\n", fen);
  }
  if (bytes_written != buffer_size)
    buffer[bytes_written++] = '\n';  // extra newline before movetext
  bytes_written += write_movetext(
      buffer + bytes_written, buffer_size - bytes_written, chess_state, fen);
  return bytes_written;
}
// Expanded from src/chess/move_is_legal.c
#include <stdio.h>
#include <stdlib.h>


int is_pinned(const chess_state_t* chess_state, move_t move, colour_t colour) {
  sq0x88_t from = get_from(move);
  sq0x88_t to = get_to(move);
  const piece_list_t* piece_list = get_piece_list(chess_state, colour);

  sq0x88_t king_square = piece_list->king_square;
  // checking moved piece is not pinned
  sq0x88_t inc = queen_increment(king_square, from);
  // piece is not aligned with king
  if (inc == 0) return 0;
  // piece is on same line with king
  if (inc == queen_increment(king_square, to)) return 0;
  // piece between moved piece and king
  if (forwards_ray_cast(chess_state, king_square, inc) != from) return 0;
  // find potential pinning piece
  sq0x88_t pinning_square = forwards_ray_cast(chess_state, from, inc);
  if (off_the_board(pinning_square) ||
      piece_is_colour(chess_state, pinning_square, colour))
    return 0;
  // only sliding pieces can pin
  if (((piece(chess_state, pinning_square) & BISHOP) &&
       bishop_increment(king_square, pinning_square)) ||
      ((piece(chess_state, pinning_square) & ROOK) &&
       rook_increment(king_square, pinning_square))) {
    return 1;
  }
  return 0;
}

int is_pinned_enpassent(const chess_state_t* chess_state, move_t move, colour_t colour) {
  sq0x88_t from = get_from(move);
  const piece_list_t* piece_list = get_piece_list(chess_state, colour);
  sq0x88_t king_square = piece_list->king_square;
  sq0x88_t inc;
  sq0x88_t pawn_inc = pawn_push_increment(colour);

  inc = bishop_increment(
      king_square, enpassent_target(chess_state) - pawn_inc);
  sq0x88_t captured_pawn =
      enpassent_target(chess_state) - pawn_inc;
  // bishop pin
  if (inc) {
    if (forwards_ray_cast(chess_state, king_square, inc) != captured_pawn)
      return 0;

    sq0x88_t pinning_square =
        forwards_ray_cast(chess_state, captured_pawn, inc);

    if (off_the_board(pinning_square) ||
        piece_is_colour(chess_state, pinning_square, colour))
      return 0;

    if (piece(chess_state, pinning_square) & BISHOP) return 1;

    return 0;
  }

  inc = rook_increment(king_square, captured_pawn);

  if (inc == 0) return 0;

  if (inc != rook_increment(king_square, from)) return 0;

  sq0x88_t square = forwards_ray_cast(chess_state, king_square, inc);

  if (square != captured_pawn && square != from) return 0;

  square = forwards_ray_cast(chess_state, square + inc, inc);

  if (off_the_board(square) || piece_is_colour(chess_state, square, colour)) return 0;

  if (piece(chess_state, square) & ROOK) return 1;

  return 0;
}

void trace_ply_stack(const chess_state_t* chess_state) {
  char buffer[512];
  fprintf(stdout, "error at ply %d %d\n", chess_state->ply_counter, chess_state->black_to_move);
  for (int i = 0; i < chess_state->ply_counter; i++) {
    move_t move = chess_state->ply_stack[i].move;
    fprintf(stdout, "%d %d %d\n", move.from, move.to, move.priority_and_flags);
    
  }
  write_movetext_debug(buffer, 512, chess_state);
  fprintf(stdout, "%s\n", buffer);
}

int is_legal_king_move(const chess_state_t* chess_state, move_t move, colour_t colour) {
  sq0x88_t from = get_from(move);
  sq0x88_t to = get_to(move);

  if (is_under_attack(chess_state, to, colour)) return 0;
  if (is_queen_castle(move)) {
    return !is_under_attack(chess_state, from - 1, colour);
  }
  if (is_king_castle(move)) {
    return !is_under_attack(chess_state, from + 1, colour);
  }
  return 1;
}

int is_moving_out_of_check(const chess_state_t* chess_state, move_t move,
                           sq0x88_t king_square, colour_t colour) {
  if (colour != chess_state->friendly_colour) return 1;
  sq0x88_t from = get_from(move);
  sq0x88_t to = get_to(move);
  if (!is_enpassent(move)) {
    if (is_capture(move) && to != checking_square(chess_state)) {
      return 0;
    }
    if (!is_capture(move)) {
      sq0x88_t inc = queen_increment(king_square, to);
      if (inc == 0 ||
          inc != queen_increment(to, checking_square(chess_state))) {
        return 0;
      }
    }
  } else {
    sq0x88_t inc = queen_increment(king_square, to);
    if (rankfile_to_sq0x88(sq0x88_to_rank07(from), sq0x88_to_file07(to)) !=
            checking_square(chess_state) &&
        (inc == 0 ||
         inc != queen_increment(to, checking_square(chess_state)))) {
      return 0;
    }
  }
  return 1;
}

// checks if pseudo legal move is legal, assumes position is not in check
int is_legal(const chess_state_t* chess_state, move_t move) {
  return is_legal_internal(chess_state, move, chess_state->friendly_colour);
}

int is_legal_internal(const chess_state_t* chess_state, move_t move, colour_t colour) {
  sq0x88_t from = get_from(move);

  // if (piece(chess_state, to) & KING) {
  //   trace_ply_stack(chess_state);
  //   printf("can capture king\n");
  //   abort();
  // }
  const piece_list_t* piece_list = get_piece_list(chess_state, colour);
  sq0x88_t king_square = piece_list->king_square;

  if (from == king_square) {  // king moves
    return is_legal_king_move(chess_state, move, colour);
  }
  //if (is_check(chess_state) && !is_moving_out_of_check(chess_state, move, king_square, colour)) {
  //  return 0;
  //}
  if (is_enpassent(move)) {
    if (is_pinned_enpassent(chess_state, move, colour)) return 0;
  }

  return !is_pinned(chess_state, move, colour);
}

int is_pseudo_legal_king_move(const chess_state_t* chess_state, move_t move, colour_t colour) {
  if (is_king_castle(move)) {
    return can_castle_king_side(chess_state, colour) && !is_check(chess_state);
  }
  if (is_queen_castle(move)) {
    return can_castle_queen_side(chess_state, colour) && !is_check(chess_state);
  }
  return king_increment(get_from(move), get_to(move)) != 0;
}

int is_pseudo_legal_knight_move(const chess_state_t* chess_state, move_t move) {
  (void)chess_state;
  return knight_increment(get_from(move), get_to(move)) != 0;
}

int is_pseudo_legal_pawn_move(const chess_state_t* chess_state, move_t move, colour_t colour) {
  sq0x88_t from = get_from(move);
  sq0x88_t to = get_to(move);
  sq0x88_t inc = pawn_push_increment(colour);
  if (is_double_pawn_push(move)) {
    return (sq0x88_to_rank07(from) == 1 || sq0x88_to_rank07(from) == 6) && (sq0x88_t)(from + 2 * inc) == to && piece_is_empty(chess_state, from + inc) &&
           piece_is_empty(chess_state, to);
  }
  if (is_enpassent(move) && enpassent_target(chess_state) != to && colour == chess_state->friendly_colour) {
    return 0;
  }
  if ((sq0x88_to_rank07(to) == 0 || sq0x88_to_rank07(to) == 7) && !is_promotion(move)) {
    return 0;
  }
  if (is_capture(move)) {
    return (to == (sq0x88_t)(from + inc + 1) || to == (sq0x88_t)(from + inc - 1));
  }
  return (to == (sq0x88_t)(from + inc) && piece_is_empty(chess_state, to));
}

int is_pseudo_legal_sliding_move(const chess_state_t* chess_state, move_t move,
                                 sq0x88_t inc) {
  sq0x88_t from = get_from(move);
  sq0x88_t to = get_to(move);
  return (backwards_ray_cast(chess_state, to, inc) == from);
}

int is_pseudo_legal_internal(const chess_state_t* chess_state, move_t move, colour_t colour) {
  sq0x88_t from = get_from(move);
  sq0x88_t to = get_to(move);
  colour_t enemy_colour = opposite_colour(colour);

  if (off_the_board(from) || off_the_board(to)) {
    return 0;  // move is out of bounds
  }
  if (is_null_move(move)) {
    return 0;  // null move
  }
  if (!piece_is_colour(chess_state, from, colour) ||
      piece_is_colour(chess_state, to, colour)) {
    // moving piece that isn't ours or doesn't exist or to square
    // occupied by our piece
    return 0;
  }

  // validate move flags
  if (is_promotion(move) && ((piece(chess_state, from) & PIECE_MASK) != PAWN ||
      !is_promoting(from, colour))) {
    return 0;
  }
  if (is_enpassent(move) && ((piece(chess_state, from) & PIECE_MASK) != PAWN ||
      enpassent_target(chess_state) != to)) {
    return 0;
  }
  if (is_queen_castle(move) &&
      ((piece(chess_state, from) & PIECE_MASK) != KING ||
      !can_castle_queen_side(chess_state, colour) || to != from - 2)) {
    return 0;
  }
  if (is_king_castle(move) && ((piece(chess_state, from) & PIECE_MASK) != KING ||
      !can_castle_king_side(chess_state, colour) || to != from + 2)) {
    return 0;
  }
  // is a capture
  if (!is_enpassent(move) && is_capture(move) &&
      !piece_is_colour(chess_state, to, enemy_colour)) {
    return 0;
  }
  if (!is_capture(move) && piece_is_colour(chess_state, to, enemy_colour)) {
    return 0;
  }
  if (is_double_pawn_push(move) && (piece(chess_state, from) & PIECE_MASK) != PAWN) {
    return 0;
  }

  // piece movement is valid
  switch (piece(chess_state, from) & PIECE_MASK) {
    case PAWN:
      
      if (!is_pseudo_legal_pawn_move(chess_state, move, colour)) {
        return 0;
      }
      break;
    case KNIGHT:
      if (!is_pseudo_legal_knight_move(chess_state, move)) {
        return 0;
      }
      break;
    case BISHOP: {
      sq0x88_t inc = bishop_increment(from, to);
      if (!inc || !is_pseudo_legal_sliding_move(chess_state, move, inc)) {
        return 0;
      }
    } break;
    case ROOK: {
      sq0x88_t inc = rook_increment(from, to);
      if (!inc || !is_pseudo_legal_sliding_move(chess_state, move, inc)) {
        return 0;
      }
    } break;
    case QUEEN: {
      sq0x88_t inc = queen_increment(from, to);
      if (!inc || !is_pseudo_legal_sliding_move(chess_state, move, inc)) {
        return 0;
      }
    } break;
    case KING:
      if (!is_pseudo_legal_king_move(chess_state, move, colour)) {
        return 0;
      }
      break;
    default:
      return 0;
  }

  // check rules for psuedo legal (ignoring pin checks & moving king to
  // threatened square)
  if (!is_check(chess_state)) {
    return 1;
  }

  if ((piece(chess_state, from) & PIECE_MASK) == KING) {
    return 1;
  }

  if (is_double_check(chess_state)) {
    return 0;
  }

  sq0x88_t check_square = checking_square(chess_state);
  // capturing checking piece
  if (is_enpassent(move) && check_square == enpassent_target(chess_state) - pawn_push_increment(colour)) {
    return 1;
  }
  if (is_capture(move) && !is_enpassent(move)) {
    return to == check_square;
  }
  // checker is not interposable
  if ((piece(chess_state, check_square) & QUEEN) == 0) {
    return 0;
  }
  sq0x88_t king_square = get_piece_list(chess_state, colour)->king_square;
  sq0x88_t interpose_inc = queen_increment(king_square, to);
  // interposing between checker and king
  if (interpose_inc == 0) {
    return 0;
  }
  if (interpose_inc != queen_increment(to, check_square)) {
    return 0;
  }
  
  return 1;
}

int is_pseudo_legal(const chess_state_t* chess_state, move_t move) {
  return is_pseudo_legal_internal(chess_state, move, chess_state->friendly_colour);
}
// Expanded from src/chess/load_position.c
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#ifdef DEBUG
#define PRINT_READ_ERRORS
#define PRINT_WRITE_ERRORS
#endif

#ifdef PRINT_READ_ERRORS
#define READ_ERROR(msg, ...)                                \
  {                                                         \
    fprintf(stderr, "READ ERROR: reading \"%s\" ", buffer); \
    fprintf(stderr, msg, ##__VA_ARGS__);                    \
    return -1;                                              \
  }
#else
#define READ_ERROR(msg, ...) \
  { return -1; }
#endif

#ifdef PRINT_WRITE_ERRORS
#define WRITE_ERROR(msg, ...)         \
  {                                   \
    fprintf(stderr, "WRITE ERROR: "); \
    printf(msg, ##__VA_ARGS__);       \
    buffer[0] = 0;                    \
    return -1;                        \
  }
#else
#define WRITE_ERROR(msg, ...) \
  {                           \
    buffer[0] = 0;            \
    return -1;                \
  }
#endif

long skip_whitespace_internal(const char* buffer) {
  long bytes_read = 0;
  while (buffer[bytes_read] == ' ' || buffer[bytes_read] == '\t' ||
         buffer[bytes_read] == '\n' || buffer[bytes_read] == '\r') {
    bytes_read++;
  }
  return bytes_read;
}


static const piece_t empty_board[RANK_SIZE * FILE_SIZE] = {
    EMPTY,  EMPTY,  EMPTY,  EMPTY,  EMPTY,  EMPTY,  EMPTY,  EMPTY,  BORDER,
    BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, EMPTY,  EMPTY,
    EMPTY,  EMPTY,  EMPTY,  EMPTY,  EMPTY,  EMPTY,  BORDER, BORDER, BORDER,
    BORDER, BORDER, BORDER, BORDER, BORDER, EMPTY,  EMPTY,  EMPTY,  EMPTY,
    EMPTY,  EMPTY,  EMPTY,  EMPTY,  BORDER, BORDER, BORDER, BORDER, BORDER,
    BORDER, BORDER, BORDER, EMPTY,  EMPTY,  EMPTY,  EMPTY,  EMPTY,  EMPTY,
    EMPTY,  EMPTY,  BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER,
    BORDER, EMPTY,  EMPTY,  EMPTY,  EMPTY,  EMPTY,  EMPTY,  EMPTY,  EMPTY,
    BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, EMPTY,
    EMPTY,  EMPTY,  EMPTY,  EMPTY,  EMPTY,  EMPTY,  EMPTY,  BORDER, BORDER,
    BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, EMPTY,  EMPTY,  EMPTY,
    EMPTY,  EMPTY,  EMPTY,  EMPTY,  EMPTY,  BORDER, BORDER, BORDER, BORDER,
    BORDER, BORDER, BORDER, BORDER, EMPTY,  EMPTY,  EMPTY,  EMPTY,  EMPTY,
    EMPTY,  EMPTY,  EMPTY,  BORDER, BORDER, BORDER, BORDER, BORDER, BORDER,
    BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER,
    BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER,
    BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER,
    BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER,
    BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER,
    BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER,
    BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER,
    BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER,
    BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER,
    BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER,
    BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER,
    BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER,
    BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER,
    BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER, BORDER,
    BORDER, BORDER, BORDER, BORDER,
};

void release_position(chess_state_t* chess_state) {
  if (chess_state->ply_stack) {
    free(chess_state->ply_stack);
    chess_state->ply_stack = NULL;
  }
}

void clear_position(chess_state_t* chess_state) {
  release_position(chess_state);

  memset(chess_state, 0, sizeof(*chess_state));
  memcpy(chess_state->board, empty_board, sizeof(empty_board));

  chess_state->friendly_colour = WHITE;
  chess_state->enemy_colour = BLACK;
  chess_state->friendly_pieces = &chess_state->white_pieces;
  chess_state->enemy_pieces = &chess_state->black_pieces;
  chess_state->up_increment = 16, chess_state->down_increment = -16;
}

void init_ply_stack(chess_state_t* chess_state) {
  chess_state->ply_stack_capacity = chess_state->ply_counter + 50ull;
  chess_state->ply_stack =
      malloc(sizeof(ply_stack_item_t) * chess_state->ply_stack_capacity);
}

void load_start_position(chess_state_t* chess_state) {
  load_position(chess_state,
                "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1");
}

void copy_position(chess_state_t* chess_state,
                   const chess_state_t* state_to_copy) {
  release_position(chess_state);
  memcpy(chess_state, state_to_copy, sizeof(chess_state_t));
  size_t ply_stack_size =
      sizeof(ply_stack_item_t) * chess_state->ply_stack_capacity;
  chess_state->ply_stack = malloc(ply_stack_size);
  memcpy(chess_state->ply_stack, state_to_copy->ply_stack, ply_stack_size);
  if (chess_state->black_to_move) {
    chess_state->friendly_pieces = &chess_state->black_pieces;
    chess_state->enemy_pieces = &chess_state->white_pieces;
  } else {
    chess_state->friendly_pieces = &chess_state->white_pieces;
    chess_state->enemy_pieces = &chess_state->black_pieces;
  }
}

piece_t parse_piece(char letter) {
  switch (letter) {
    case 'K':
      return WHITE_KING;
    case 'Q':
      return WHITE_QUEEN;
    case 'R':
      return WHITE_ROOK;
    case 'B':
      return WHITE_BISHOP;
    case 'N':
      return WHITE_KNIGHT;
    case 'P':
      return WHITE_PAWN;
    case 'k':
      return BLACK_KING;
    case 'q':
      return BLACK_QUEEN;
    case 'r':
      return BLACK_ROOK;
    case 'b':
      return BLACK_BISHOP;
    case 'n':
      return BLACK_KNIGHT;
    case 'p':
      return BLACK_PAWN;
    default:
      return EMPTY;
  }
}

long load_position(chess_state_t* chess_state, const char* buffer) {
  long bytes_read = 0;
  long size = strlen(buffer) + 1;

  clear_position(chess_state);

  // pieces
  if (buffer[bytes_read] == '\0' || bytes_read >= size) {
    READ_ERROR("fen missing piece table.\n");
  }
  for (int rank = 7; rank >= 0; rank--) {
    int file = 0;
    while (file < 8) {
      if (bytes_read >= size) READ_ERROR("fen missing piece table\n");
      char letter = buffer[bytes_read++];
      if (letter >= '1' && letter <= '8') {
        file += letter - '0';
        continue;
      }
      piece_t piece_to_add = parse_piece(letter);
      if (piece_to_add == EMPTY) {
        READ_ERROR("invalid piece \'%c\' in fen piece table\n", letter);
      }
      place_piece(chess_state, rankfile_to_sq0x88(rank, file), piece_to_add);
      file++;
    }
    if (file != 8) {
      READ_ERROR("too many pieces in rank %d\n", rank);
    }
    if (rank != 0 && (bytes_read >= size || buffer[bytes_read++] != '/')) {
      READ_ERROR("row in fen piece table not seperated with \'/\'");
    }
  }

  bytes_read += skip_whitespace_internal(buffer + bytes_read);

  // next to move
  if (buffer[bytes_read] == '\0' || bytes_read >= size) {
    READ_ERROR("fen missing player to move.\n");
  }
  char who2move = buffer[bytes_read++];
  switch (who2move) {
    case 'w':
      break;
    case 'b':
      update_turn(chess_state);
      break;
    default:
      READ_ERROR(
          "invalid code for player to move \'%c\', must be \'w\' or \'b\'.\n",
          who2move);
  }

  bytes_read += skip_whitespace_internal(buffer + bytes_read);
  // castle rights
  if (buffer[bytes_read] == '\0' || bytes_read >= size) {
    READ_ERROR("fen missing castle rights.\n");
  }

  if (bytes_read < size && buffer[bytes_read] == '-') {
    bytes_read++;
  } else {
    if (bytes_read < size && buffer[bytes_read] == 'K') {
      chess_state->castle_rights |= WHITE_KING_SIDE;
      bytes_read++;
    }
    if (bytes_read < size && buffer[bytes_read] == 'Q') {
      chess_state->castle_rights |= WHITE_QUEEN_SIDE;
      bytes_read++;
    }
    if (bytes_read < size && buffer[bytes_read] == 'k') {
      chess_state->castle_rights |= BLACK_KING_SIDE;
      bytes_read++;
    }
    if (bytes_read < size && buffer[bytes_read] == 'q') {
      chess_state->castle_rights |= BLACK_QUEEN_SIDE;
      bytes_read++;
      ;
    }
  }

  bytes_read += skip_whitespace_internal(buffer + bytes_read);

  // en passent
  if (buffer[bytes_read] == '\0' || bytes_read >= size) {
    READ_ERROR("fen missing enpassent target.\n");
  }

  if (bytes_read < size && buffer[bytes_read] == '-') {
    chess_state->enpassent_target = -1;
    bytes_read++;
  } else {
    int out = read_square(buffer + bytes_read, size - bytes_read,
                          &chess_state->enpassent_target);
    if (out == -1) return -1;
    bytes_read += out;
    if (sq0x88_to_rank07(chess_state->enpassent_target) != 2 &&
        sq0x88_to_rank07(chess_state->enpassent_target) != 5) {
      READ_ERROR("fen contains invalid enpassent target.\n");
    }
  }

  bytes_read += skip_whitespace_internal(buffer + bytes_read);
  // everything past here is optional

  // half move clock
  if (bytes_read < size && buffer[bytes_read] >= '0' &&
      buffer[bytes_read] <= '9') {
    int half_move_clock = buffer[bytes_read++] - '0';
    while (bytes_read < size && buffer[bytes_read] >= '0' &&
        buffer[bytes_read] <= '9') {
      half_move_clock = 10 * half_move_clock + buffer[bytes_read] - '0';
      bytes_read++;
    }
    chess_state->half_move_clock = half_move_clock;
    bytes_read += skip_whitespace_internal(buffer + bytes_read);
  }

  // full move counter
  if (bytes_read < size && buffer[bytes_read] >= '1' &&
      buffer[bytes_read] <= '9') {
    int move_counter = buffer[bytes_read++] - '0';
    while (bytes_read < size && buffer[bytes_read] >= '0' &&
           buffer[bytes_read] <= '9') {
      move_counter = 10 * move_counter + buffer[bytes_read++] - '0';
    }
    chess_state->ply_counter =
        (move_counter - 1) * 2 + chess_state->black_to_move;
  }

  chess_state->ply_of_last_irreversible_move = chess_state->ply_counter;

  init_check(chess_state);
  init_ply_stack(chess_state);
  return bytes_read;
}

long write_number(char* buffer, long buffer_size, int number) {
  long bytes_written = 0;
  if (number == 0) {
    if (bytes_written + 1 >= buffer_size)
      WRITE_ERROR("insufficient space in buffer");
    buffer[bytes_written++] = '0';
  } else {
    while (number > 0) {
      if (bytes_written + 1 >= buffer_size)
        WRITE_ERROR("insufficient space in buffer");
      buffer[bytes_written++] = '0' + (number % 10);
      number /= 10;
    }
    for (int i = 0; i < bytes_written / 2; i++) {
      int temp = buffer[i];
      buffer[i] = buffer[bytes_written - i - 1];
      buffer[bytes_written - i - 1] = temp;
    }
  }
  return bytes_written;
}

// @todo correctly handle reaching end of buffer, correctly handle errors
long save_position(const chess_state_t* chess_state, char* buffer, long size) {
  // save piece table
  long bytes_written = 0;
  for (int r = 7; r >= 0; r--) {
    int empties = 0;
    for (int f = 0; f < 8; f++) {
      piece_t p = piece(chess_state, rankfile_to_sq0x88(r, f));
      if (p == EMPTY) {
        empties++;
        continue;
      }
      if (bytes_written + 1 >= size)
        WRITE_ERROR("insufficient space in buffer");
      if (empties > 0) {
        buffer[bytes_written++] = empties + '0';
        empties = 0;
      }
      switch (p) {
        case WHITE_PAWN:
          buffer[bytes_written++] = 'P';
          break;
        case WHITE_KNIGHT:
          buffer[bytes_written++] = 'N';
          break;
        case WHITE_BISHOP:
          buffer[bytes_written++] = 'B';
          break;
        case WHITE_ROOK:
          buffer[bytes_written++] = 'R';
          break;
        case WHITE_QUEEN:
          buffer[bytes_written++] = 'Q';
          break;
        case WHITE_KING:
          buffer[bytes_written++] = 'K';
          break;
        case BLACK_PAWN:
          buffer[bytes_written++] = 'p';
          break;
        case BLACK_KNIGHT:
          buffer[bytes_written++] = 'n';
          break;
        case BLACK_BISHOP:
          buffer[bytes_written++] = 'b';
          break;
        case BLACK_ROOK:
          buffer[bytes_written++] = 'r';
          break;
        case BLACK_QUEEN:
          buffer[bytes_written++] = 'q';
          break;
        case BLACK_KING:
          buffer[bytes_written++] = 'k';
          break;
        default:
          WRITE_ERROR("unexpected piece type %02x", p);
      }
    }
    if (empties > 0) {
      if (bytes_written + 1 >= size)
        WRITE_ERROR("insufficient space in buffer");
      buffer[bytes_written++] = empties + '0';
      empties = 0;
    }
    if (r != 0) {
      if (bytes_written + 1 >= size)
        WRITE_ERROR("insufficient space in buffer");
      buffer[bytes_written++] = '/';
    }
  }
  if (bytes_written + 1 >= size) WRITE_ERROR("insufficient space in buffer");
  buffer[bytes_written++] = ' ';

  // player to move
  if (bytes_written + 2 >= size) WRITE_ERROR("insufficient space in buffer");
  buffer[bytes_written++] = chess_state->black_to_move ? 'b' : 'w';
  buffer[bytes_written++] = ' ';

  // castle rights
  if (chess_state->castle_rights == NO_RIGHTS) {
    if (bytes_written + 1 >= size) WRITE_ERROR("insufficient space in buffer");
    buffer[bytes_written++] = '-';
  } else {
    if (chess_state->castle_rights & WHITE_KING_SIDE) {
      if (bytes_written + 1 >= size)
        WRITE_ERROR("insufficient space in buffer");
      buffer[bytes_written++] = 'K';
    }
    if (chess_state->castle_rights & WHITE_QUEEN_SIDE) {
      if (bytes_written + 1 >= size)
        WRITE_ERROR("insufficient space in buffer");
      buffer[bytes_written++] = 'Q';
    }
    if (chess_state->castle_rights & BLACK_KING_SIDE) {
      if (bytes_written + 1 >= size)
        WRITE_ERROR("insufficient space in buffer");
      buffer[bytes_written++] = 'k';
    }
    if (chess_state->castle_rights & BLACK_QUEEN_SIDE) {
      if (bytes_written + 1 >= size)
        WRITE_ERROR("insufficient space in buffer");
      buffer[bytes_written++] = 'q';
    }
  }
  if (bytes_written + 1 >= size) WRITE_ERROR("insufficient space in buffer");
  buffer[bytes_written++] = ' ';

  // enpassent
  if (!off_the_board(enpassent_target(chess_state))) {
    long out = write_square(buffer + bytes_written, size - bytes_written,
                            enpassent_target(chess_state));
    if (out == -1) return -1;
    bytes_written += out;
  } else {
    if (bytes_written + 1 >= size) WRITE_ERROR("insufficient space in buffer");
    buffer[bytes_written++] = '-';
  }
  if (bytes_written + 1 >= size) WRITE_ERROR("insufficient space in buffer");
  buffer[bytes_written++] = ' ';

  // half move clock

  long out = write_number(buffer + bytes_written, size - bytes_written,
                          chess_state->half_move_clock);
  if (out == -1) return -1;
  bytes_written += out;

  if (bytes_written + 1 >= size) WRITE_ERROR("insufficient space in buffer");
  buffer[bytes_written++] = ' ';

  // full move count
  int turn_number = chess_state->ply_counter / 2 + 1;
  out = write_number(buffer + bytes_written, size - bytes_written, turn_number);
  if (out == -1) return -1;
  bytes_written += out;

  return bytes_written;
}
// Expanded from src/eval/search.c


int rootSearch(worker_t* worker, centipawn_t alpha, centipawn_t beta, int depth) {
  (void)beta;
  // aliasing thread data
  chess_state_t* position = &worker->position;
  atomic_fetch_add(&worker->bot->nodes_searched, 1);

  move_t* moves = worker->moves;
  size_t move_count = worker->move_count;
  centipawn_t* scores = worker->scores;

  make_move(position, moves[0]);
  scores[0] = -abSearch(worker, MINSCORE, MAXSCORE, depth - 1);
  unmake_move(position);

  for (size_t i = 1; !stop(worker) && i < move_count; i++) {
    make_move(position, moves[i]);
    scores[i] = -abSearch(worker, -scores[0] - 1, -scores[0], depth - 1);
    if (scores[i] > alpha) {
      scores[i] = -abSearch(worker, MINSCORE, -scores[0], depth - 1);
    }
    unmake_move(position);

    if (stop(worker)) break;

    for (int j = i; j > 0; j--) {
      if (scores[j - 1] < scores[j]) {
        centipawn_t temp_score = scores[j - 1];
        scores[j - 1] = scores[j];
        scores[j] = temp_score;

        move_t temp_move = moves[j - 1];
        moves[j - 1] = moves[j];
        moves[j] = temp_move;
        continue;
      }
      break;
    }
  }
  return 0;
}

centipawn_t abSearch(worker_t* worker, centipawn_t alpha, centipawn_t beta,
                    int depth) {
  // aliasing thread data
  chess_state_t* position = &worker->position;
  table_t* table = &worker->bot->transpostion_table;
  int ply = position->ply_counter- worker->root_ply;


  if (depth <= 0 && !is_check(position)) {
    return qSearch(worker, alpha, beta, depth);
  }
  
  atomic_fetch_add(&worker->bot->nodes_searched, 1);

  if (is_draw_by_50_move_rule(position) || is_draw_by_insufficient_material(position) ||
      is_repetition(position, worker->root_ply)) {
    return DRAW_SCORE;
  }

  entry_t tt_entry = tt_get(table, position->zobrist);
  move_t hash_move = null_move;
  if (tt_entry) {
    int tt_entry_type = entry_type(tt_entry);
    centipawn_t tt_score = entry_score(tt_entry);
    if (entry_depth(tt_entry) >= depth) {
      if (tt_entry_type == TT_EXACT ||
          (tt_entry_type == TT_UPPER && tt_score <= alpha) ||
          (tt_entry_type == TT_LOWER && tt_score >= beta)) {
        return tt_score;
      }
    }
    hash_move = entry_best_move(tt_entry);
  }

  move_list_t move_list;
  init_move_list(position, &move_list, hash_move, worker->killer_moves[depth], worker->history_heuristic, worker->butterfly_heuristic);

  move_t best_move = next_move(position, &move_list);

  if (is_null_move(best_move)) {
    if (is_check(position)) {
      return CHECKMATE_SCORE - depth;
    } else {
      return DRAW_SCORE;
    }
  }

  make_move(position, best_move);
  centipawn_t best_score = -abSearch(worker, -beta, -alpha, depth - 1);
  unmake_move(position);

  if (!is_capture(best_move) && !is_promotion(best_move)) {
    inc_butteryfly_board(worker->butterfly_heuristic, best_move);
  }
  if (best_score > alpha) {
    if (best_score >= beta) {
      tt_store_depth_prefered(table, position->zobrist, TT_LOWER, best_move,
                              best_score, depth, 0);
      if (!is_capture(best_move) && !is_promotion(best_move)) {
        inc_butteryfly_board(worker->history_heuristic, best_move);
        add_killer_move(worker->killer_moves[ply], best_move);
      }
      return best_score;
    }
    alpha = best_score;
  }
  move_t move;
  while (!is_null_move(move = next_move(position, &move_list)) &&
         !stop(worker)) {
    make_move(position, move);
    centipawn_t score = -abSearch(worker, -alpha - 1, -alpha, depth - 1);
    if (score > alpha && score < beta) {
      score = -abSearch(worker, -beta, -alpha, depth - 1);
      if (score > alpha) {
        alpha = score;
      }
    }
    unmake_move(position);
    if (score > best_score) {
      if (score > alpha) {
        alpha = score;
      }
      if (!is_capture(best_move) && !is_promotion(best_move)) {
        inc_butteryfly_board(worker->butterfly_heuristic, best_move);
      }
      if (score >= beta) {
        tt_store_depth_prefered(table, position->zobrist, TT_LOWER, move, score,
                                depth, 0);
        if (!is_capture(move) && !is_promotion(move)) {
          inc_butteryfly_board(worker->history_heuristic, move);
          add_killer_move(worker->killer_moves[ply], move);
        }
        return score;
      }
      best_score = score;
      best_move = move;
    }
  }
  enum tt_entry_type entry_type = (best_score > alpha) ? TT_EXACT : TT_UPPER;
  tt_store_depth_prefered(table, position->zobrist, entry_type, best_move,
                          best_score, depth, 0);
  return best_score;
}


centipawn_t qSearch(worker_t* worker, centipawn_t alpha, centipawn_t beta,
                   int depth) {
  chess_state_t* position = &worker->position;

  if (is_check(position)) {
    return abSearch(worker, alpha, beta, depth);
  }

  atomic_fetch_add(&worker->bot->nodes_searched, 1);

  if (is_draw(position)) {
    return DRAW_SCORE;
  }

  move_list_t move_list;
  init_move_list(position, &move_list, null_move, worker->killer_moves[depth], worker->history_heuristic, worker->butterfly_heuristic);

  centipawn_t stand_pat = eval(position);

  if (stand_pat >= beta) {
    return stand_pat;
  }

  //if (stand_pat + 950 < alpha) {
  //  return stand_pat;
  //}

  if (stand_pat > alpha) {
    alpha = stand_pat;
  }


  centipawn_t best_score = stand_pat;
  move_t move;
  while (!is_null_move(move = next_capture(position, &move_list)) && !stop(worker)) {
    if (!is_promotion(move) && static_exchange_evaluation(position, move) < 0) {
      continue;
    }

    //if (stand_pat + piece_value(move.to, piece(position, move.to)) < alpha - 200) {
    //  continue;
    //}

    make_move(position, move);
    centipawn_t score = -qSearch(worker, -beta, -alpha, depth - 1);
    unmake_move(position);

    if (score >= beta) {
      return score;
    }

    if (score > best_score) {
      best_score = score;
      if (score > alpha) {
        alpha = score;
      }
    }
  }

  return best_score;
}
// Expanded from src/eval/see.c


typedef struct {
  centipawn_t value;
  sq0x88_t square;
  uint8_t padding;
} attacker_t;

typedef struct {
  int piece_count;
  attacker_t pieces[16];
} attacker_list_t;

void add_attacker(attacker_list_t* attackers, sq0x88_t square,
                  centipawn_t piece_value) {
  attackers->pieces[attackers->piece_count++] =
      (attacker_t){square, piece_value, 0};
}

// finds all direct attackers and defenders
void generate_attackers(const chess_state_t* chess_state,
                        attacker_list_t* attackers, attacker_list_t* defenders,
                        sq0x88_t from, sq0x88_t to) {
  *attackers = (attacker_list_t){.piece_count = 0};
  *defenders = (attacker_list_t){.piece_count = 0};

  sq0x88_t first_attack_increment = queen_increment(from, to);

  // pawns
  sq0x88_t pawn_square;
  pawn_square = to - chess_state->up_increment + 1;
  if (pawn_square != from && piece(chess_state, pawn_square) ==
                                 (PAWN | chess_state->friendly_colour)) {
    add_attacker(attackers, pawn_square, PAWN_SCORE);
  }
  pawn_square = to - chess_state->up_increment + 1;
  if (pawn_square != from && piece(chess_state, pawn_square) ==
                                 (PAWN | chess_state->friendly_colour)) {
    add_attacker(attackers, pawn_square, PAWN_SCORE);
  }
  pawn_square = to - chess_state->down_increment + 1;
  if (piece(chess_state, pawn_square) == (PAWN | chess_state->enemy_colour)) {
    add_attacker(attackers, pawn_square, PAWN_SCORE);
  }
  pawn_square = to - chess_state->down_increment + 1;
  if (piece(chess_state, pawn_square) == (PAWN | chess_state->enemy_colour)) {
    add_attacker(attackers, pawn_square, PAWN_SCORE);
  }
  // knights
  for (int i = 0; i < chess_state->friendly_pieces->knight_count; i++) {
    sq0x88_t knight_square = chess_state->friendly_pieces->knight_list[i];
    if (knight_square != from && !knight_increment(knight_square, to)) continue;
    add_attacker(attackers, knight_square, PAWN_SCORE);
  }
  for (int i = 0; i < chess_state->enemy_pieces->knight_count; i++) {
    sq0x88_t knight_square = chess_state->enemy_pieces->knight_list[i];
    if (!knight_increment(knight_square, to)) continue;
    add_attacker(defenders, knight_square, KNIGHT_SCORE);
  }
  // bishops
  for (int i = 0; i < BISHOP_INCREMENTS_COUNT; i++) {
    sq0x88_t inc = bishop_increments_list[i];
    sq0x88_t square;
    if (first_attack_increment == inc) {
      square = forwards_ray_cast(chess_state, from, inc);
    } else {
      square = forwards_ray_cast(chess_state, to, inc);
    }
    piece_t p = piece(chess_state, square);

    if (!(p & BISHOP)) continue;

    if (p & chess_state->friendly_colour) {
      centipawn_t value = 0;
      if ((p & PIECE_MASK) == BISHOP) value = BISHOP_SCORE;
      if ((p & PIECE_MASK) == QUEEN) value = QUEEN_SCORE;
      add_attacker(attackers, square, value);
    } else {
      centipawn_t value = 0;
      if ((p & PIECE_MASK) == BISHOP) value = BISHOP_SCORE;
      if ((p & PIECE_MASK) == QUEEN) value = QUEEN_SCORE;
      add_attacker(defenders, square, value);
    }
  }
  // rooks
  for (int i = 0; i < ROOK_INCREMENTS_COUNT; i++) {
    sq0x88_t inc = rook_increments_list[i];
    sq0x88_t square;
    if (first_attack_increment == inc) {
      square = forwards_ray_cast(chess_state, from, inc);
    } else {
      square = forwards_ray_cast(chess_state, to, inc);
    }
    piece_t p = piece(chess_state, square);
    if (!(p & ROOK)) continue;

    if (p & chess_state->friendly_colour) {
      centipawn_t value = 0;
      if ((p & PIECE_MASK) == ROOK) value = ROOK_SCORE;
      if ((p & PIECE_MASK) == QUEEN) value = QUEEN_SCORE;

      add_attacker(attackers, square, value);
    } else {
      centipawn_t value = 0;
      if ((p & PIECE_MASK) == ROOK) value = ROOK_SCORE;
      if ((p & PIECE_MASK) == QUEEN) value = QUEEN_SCORE;
      add_attacker(defenders, square, value);
    }
  }

  // king
  sq0x88_t king_square;
  king_square = chess_state->friendly_pieces->king_square;
  if (king_increment(king_square, to)) {
    add_attacker(attackers, king_square, KING_SCORE);
  }
  king_square = chess_state->enemy_pieces->king_square;
  if (king_increment(king_square, to)) {
    add_attacker(defenders, king_square, KING_SCORE);
  }
}

void update_xray_attackers(const chess_state_t* chess_state,
                           attacker_list_t* attackers,
                           attacker_list_t* defenders, sq0x88_t from,
                           sq0x88_t to) {
  sq0x88_t inc = queen_increment(from, to);
  if (!inc) return;
  sq0x88_t square = forwards_ray_cast(chess_state, from, inc);
  if (off_the_board(square)) return;
  piece_t attacker = piece(chess_state, square);
  if (!(bishop_increment(from, to) && attacker & BISHOP) &&
      !(rook_increment(from, to) && attacker & ROOK))
    return;
  centipawn_t value = piece_value(square, attacker);
  if (attacker & chess_state->friendly_colour) {
    add_attacker(attackers, square, value);
  } else {
    add_attacker(defenders, square, value);
  }
}

// select and erase the least valuable attacker, returning the square
attacker_t next_attacker(attacker_list_t* attackers) {
  centipawn_t least_value = attackers->pieces[0].value;
  int least_index = 0;
  for (int i = 1; i < attackers->piece_count; i++) {
    if (attackers->pieces[i].value < least_value) {
      least_value = attackers->pieces[i].value;
      least_index = i;
    }
  }
  attacker_t attacker = attackers->pieces[least_index];

  attackers->pieces[least_index] = attackers->pieces[--attackers->piece_count];

  return attacker;
}

centipawn_t static_exchange_evaluation(const chess_state_t* chess_state,
                                      move_t move) {
  centipawn_t alpha, beta;
  centipawn_t value, value_attacker;
  attacker_t next;
  sq0x88_t from = get_from(move);
  sq0x88_t to = get_to(move);

  value = piece_value(to, piece(chess_state, to));
  alpha = MINSCORE;
  beta = value;
  next.square = from;
  next.value = piece_value(from, piece(chess_state, from));

  attacker_list_t attacker_list;
  attacker_list_t defender_list;

  generate_attackers(chess_state, &attacker_list, &defender_list, from, to);

  if (attacker_list.piece_count == 0) return value;
  if (piece(chess_state, from) & KING) return alpha;
  value_attacker = next.value;
  for (;;) {
    value -= value_attacker;
    if (value >= beta) return beta;
    if (value > alpha) alpha = value;
    if (alpha > 0) return alpha;
    next = next_attacker(&defender_list);
    update_xray_attackers(chess_state, &attacker_list, &defender_list,
                          next.square, to);

    if (attacker_list.piece_count <= 0) break;
    if (piece(chess_state, next.square) & KING) return beta;
    value_attacker = next.value;

    value += value_attacker;
    if (value <= alpha) return alpha;
    if (value < alpha) beta = value;
    if (beta < 0) return beta;
    next = next_attacker(&attacker_list);
    update_xray_attackers(chess_state, &attacker_list, &defender_list,
                          next.square, to);
    if (defender_list.piece_count <= 0) break;
    if (piece(chess_state, next.square) & KING) return alpha;
    value_attacker = next.value;
  }
  if (value < alpha) return alpha;
  if (value > beta) return beta;
  return value;
}

// Expanded from src/eval/transposition_table.c

#include <stdlib.h>

// layout
// 0..2 type
// 2..16 unused
// 16..24 age
// 24..32 depth
// 32..48 score
// 48..64 best move

move_t entry_best_move(entry_t entry) {
  uint16_t compressed_move = ((entry >> 48) & 0xFFFF);
  return uncompress_move(compressed_move);
}

centipawn_t entry_score(entry_t entry) {
  return (centipawn_t)((entry >> 32) & 0xFFFF);
}

enum tt_entry_type entry_type(entry_t entry) {
  return (enum tt_entry_type)(entry & 0x3);
}

int entry_depth(entry_t entry) { return (int)((entry >> 16) & 0xFF); }

int entry_age(entry_t entry) { return (int)((entry >> 24) & 0xFF); }

entry_t make_entry(enum tt_entry_type type, move_t best_move, centipawn_t score,
                   int depth, int age) {
  return (entry_t)((entry_t)(type & 0x3) | ((entry_t)(age & 0xFF) << 24) |
                   ((entry_t)(depth & 0xFF) << 16) |
                   ((entry_t)(score & 0xFFFF) << 32) |
                   ((entry_t)compress_move(best_move) << 48));
}

void tt_init(table_t* table, uint64_t size) {
  uint64_t capacity = size / sizeof(key_entry_pair_t);
  table->items = calloc(capacity, sizeof(key_entry_pair_t));
  table->capacity = capacity;
}

void tt_free(table_t* table) { free((void*)table->items); }

entry_t tt_get(table_t* table, zobrist_t key) {
  uint64_t index = key % table->capacity;
  zobrist_t stored_key = table->items[index].key;
  uint64_t stored_entry = table->items[index].entry;
  if ((stored_key ^ stored_entry) == key) {
    return stored_entry;
  }
  return (entry_t)0;
}

void tt_store(table_t* table, zobrist_t key, enum tt_entry_type type,
              move_t best_move, centipawn_t score, int depth, int age) {
  uint64_t index = key % table->capacity;
  entry_t entry = make_entry(type, best_move, score, depth, age);
  table->items[index].key = key ^ entry;
  table->items[index].entry = entry;
}

void tt_store_depth_prefered(table_t* table, zobrist_t key,
                             enum tt_entry_type type, move_t best_move,
                             centipawn_t score, int depth, int age) {
  uint64_t index = key % table->capacity;
  uint64_t stored_entry = table->items[index].entry;
  if (!stored_entry || entry_depth(stored_entry) < depth) {
    entry_t entry = make_entry(type, best_move, score, depth, age);
    table->items[index].key = key ^ entry;
    table->items[index].entry = entry;
  }
}

void tt_store_pv(table_t* table, zobrist_t key, enum tt_entry_type type,
                 move_t best_move, centipawn_t score, int depth, int age) {
  if (type == TT_EXACT) {
    uint64_t index = key % table->capacity;
    entry_t entry = make_entry(type, best_move, score, depth, age);
    table->items[index].key = key ^ entry;
    table->items[index].entry = entry;
  }
}
// Expanded from src/eval/eval.c

// @todo piece square tables
centipawn_t eval(const chess_state_t* position) {
  
  if (is_draw(position)) {
    return DRAW_SCORE;
  }

  if (is_checkmate(position)) {
    return CHECKMATE_SCORE;
  }
  
  if (is_stalemate(position)) {
    return DRAW_SCORE;
  }

  centipawn_t score =
       + position->friendly_pieces->pawn_count         * PAWN_SCORE
       - position->enemy_pieces->pawn_count            * PAWN_SCORE
       + position->friendly_pieces->knight_count       * KNIGHT_SCORE
       - position->enemy_pieces->knight_count          * KNIGHT_SCORE
       + position->friendly_pieces->light_bishop_count * BISHOP_SCORE
       - position->enemy_pieces->light_bishop_count    * BISHOP_SCORE
       + position->friendly_pieces->dark_bishop_count  * BISHOP_SCORE
       - position->enemy_pieces->dark_bishop_count     * BISHOP_SCORE
       + position->friendly_pieces->rook_count         * ROOK_SCORE
       - position->enemy_pieces->rook_count            * ROOK_SCORE
       + position->friendly_pieces->queen_count        * QUEEN_SCORE
       - position->enemy_pieces->queen_count           * QUEEN_SCORE;

       score += material_score(position);

  return score;
}

sq0x88_t flipped_square(sq0x88_t sq) {
  return rankfile_to_sq0x88(7 - sq0x88_to_rank07(sq),
                            sq0x88_to_file07(sq));
}

centipawn_t material_score(const chess_state_t* chess_state) {
  centipawn_t score = 0;

  {
    sq0x88_t sq = chess_state->white_pieces.king_square;
    score += king_square_table[sq0x88_to_sq8x8(sq)];
  }
  {
    sq0x88_t sq = flipped_square(chess_state->black_pieces.king_square);
    score -= king_square_table[sq0x88_to_sq8x8(sq)];
  }
  for (int p = 0; p < chess_state->white_pieces.pawn_count; p++) {
    sq0x88_t sq = chess_state->white_pieces.pawn_list[p];
    score += pawn_square_table[sq0x88_to_sq8x8(sq)];
  }
  for (int p = 0; p < chess_state->black_pieces.pawn_count; p++) {
    sq0x88_t sq = flipped_square(chess_state->black_pieces.pawn_list[p]);
    score -= pawn_square_table[sq0x88_to_sq8x8(sq)];
  }
  for (int p = 0; p < chess_state->white_pieces.knight_count; p++) {
    sq0x88_t sq = chess_state->white_pieces.knight_list[p];
    score += knight_square_table[sq0x88_to_sq8x8(sq)];
  }
  for (int p = 0; p < chess_state->black_pieces.knight_count; p++) {
    sq0x88_t sq = flipped_square(chess_state->black_pieces.knight_list[p]);
    score -= knight_square_table[sq0x88_to_sq8x8(sq)];
  }
  for (int p = 0; p < chess_state->white_pieces.light_bishop_count; p++) {
    sq0x88_t sq = chess_state->white_pieces.light_bishop_list[p];
    score += bishop_square_table[sq0x88_to_sq8x8(sq)];
  }
  for (int p = 0; p < chess_state->black_pieces.light_bishop_count; p++) {
    sq0x88_t sq = flipped_square(chess_state->black_pieces.light_bishop_list[p]);
    score -= bishop_square_table[sq0x88_to_sq8x8(sq)];
  }
  for (int p = 0; p < chess_state->white_pieces.dark_bishop_count; p++) {
    sq0x88_t sq = chess_state->white_pieces.dark_bishop_list[p];
    score += bishop_square_table[sq0x88_to_sq8x8(sq)];
  }
  for (int p = 0; p < chess_state->black_pieces.dark_bishop_count; p++) {
    sq0x88_t sq = flipped_square(chess_state->black_pieces.dark_bishop_list[p]);
    score -= bishop_square_table[sq0x88_to_sq8x8(sq)];
  }
  for (int p = 0; p < chess_state->white_pieces.rook_count; p++) {
    sq0x88_t sq = chess_state->white_pieces.rook_list[p];
    score += rook_square_table[sq0x88_to_sq8x8(sq)];
  }
  for (int p = 0; p < chess_state->black_pieces.rook_count; p++) {
    sq0x88_t sq = flipped_square(chess_state->black_pieces.rook_list[p]);
    score -= rook_square_table[sq0x88_to_sq8x8(sq)];
  }
  for (int p = 0; p < chess_state->white_pieces.queen_count; p++) {
    sq0x88_t sq = chess_state->white_pieces.queen_list[p];
    score += queen_square_table[sq0x88_to_sq8x8(sq)];
  }
  for (int p = 0; p < chess_state->black_pieces.queen_count; p++) {
    sq0x88_t sq = flipped_square(chess_state->black_pieces.queen_list[p]);
    score -= queen_square_table[sq0x88_to_sq8x8(sq)];
  }

  return chess_state->black_to_move ? -score : score;
}


centipawn_t piece_value(sq0x88_t sq, piece_t p) {
  (void)sq;
  switch (p & PIECE_MASK) {
    case PAWN: return PAWN_SCORE;
    case KNIGHT: return KNIGHT_SCORE;
    case BISHOP: return BISHOP_SCORE;
    case ROOK: return ROOK_SCORE;
    case QUEEN: return QUEEN_SCORE;
    case KING: return KING_SCORE;
    default: return 0;
  }
}

int is_repetition(const chess_state_t* chess_state, int ply_of_root) {
  if (chess_state->ply_counter - chess_state->ply_of_last_irreversible_move <
      3) {
    return 0;
  }
  zobrist_t current_zobrist = chess_state->zobrist;
  int repetitions = 1;
  for (int i = chess_state->ply_counter - 2;
       i >= chess_state->ply_of_last_irreversible_move; i -= 2) {
    if (chess_state->ply_stack[i].zobrist == current_zobrist) {
      if (i >= ply_of_root) {
        return 1;
      }
      repetitions++;
    }
  }
  return repetitions >= 3;
}
// Expanded from src/eval/worker.c

#include <stdio.h>
#include <time.h>
#include <pthread.h>
#include <stdatomic.h>

void bot_on_stop(bot_t* bot) {
    for (int id = 1; id < bot->n_threads; id++) {
        pthread_join(bot->workers[id]->handle, NULL);
    }
    log_info(bot);
    bestmove(bot->workers[0]->moves[0], null_move);
    atomic_store(&bot->running, 0);
}

void* worker_start(void* arg) {
  worker_t* worker = (worker_t*)arg;
  bot_t* bot = worker->bot;


  copy_position(&worker->position, &bot->root_position);
  worker->move_count = generate_legal_moves(&worker->position, worker->moves, bot->root_position.friendly_colour);
  worker->root_ply = worker->position.ply_counter;
  reset_butterfly_board(worker->history_heuristic);
  reset_butterfly_board(worker->butterfly_heuristic);

  while (!stop(worker)) {
    rootSearch(worker, MINSCORE, MAXSCORE, bot->depth_searched);
    bot->depth_searched++;
  }

  release_position(&worker->position);
  worker->terminated = 1;

  if (is_main_thread(worker)) {
    bot_on_stop(bot);
  }
  
  return NULL;
}

long time_passed(const struct timespec* start_time) {
  struct timespec curr_time;
  clock_gettime(CLOCK_MONOTONIC, &curr_time);
  long delta_s = (curr_time.tv_sec - start_time->tv_sec);
  long delta_ns = (curr_time.tv_nsec - start_time->tv_nsec);
  long duration_ms = delta_s * 1000 + delta_ns / (1000 * 1000);
  return duration_ms;
}

int stop(worker_t* worker) {
  bot_term_cond_t* stop_cond = &worker->bot->stop_cond;
  bot_t* bot = worker->bot;
  if (atomic_load(&bot->abort)) {
    return 1;
  }
  if (stop_cond->time_limit_ms > 0 &&
      time_passed(&bot->start_time) > stop_cond->time_limit_ms) {
    atomic_store(&bot->abort, 1);
    return 1;
  }
  if (stop_cond->node_limit_nds > 0 &&
      atomic_load(&bot->nodes_searched) > stop_cond->node_limit_nds) {
    atomic_store(&bot->abort, 1);
    return 1;
  }
  if (stop_cond->depth_limit_ply > 0 &&
      atomic_load(&bot->depth_searched) > stop_cond->depth_limit_ply) {
    atomic_store(&bot->abort, 1);
    return 1;
  }
  return 0;
}

int is_main_thread(const worker_t* worker) {
  return (uintptr_t)worker == (uintptr_t)(worker->bot->workers[0]);
}

void log_info(const bot_t* bot) {
  fprintf(stdout, "info depth %ld nodes %ld time %ld score %d\n",
          atomic_load(&bot->depth_searched), atomic_load(&bot->nodes_searched),
          time_passed(&bot->start_time), bot->workers[0]->scores[0]);
  fflush(stdout);
}

void bestmove(move_t bestmove, move_t ponder) {
  char buffer[8];
  write_long_algebraic_notation(buffer, 8, bestmove);
  fprintf(stdout, "bestmove %s", buffer);
  if (!is_null_move(ponder)) {
    write_long_algebraic_notation(buffer, 8, ponder);
    fprintf(stdout, " ponder %s", buffer);
  }
  fprintf(stdout, "\n");
  fflush(stdout);
}
// Expanded from src/eval/bot.c

#include <pthread.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define BOT_THREAD_COUNT_DEFAULT 1
#define BOT_HASH_SIZE_MB_DEFAULT 4
#define BOT_CAN_PONDER_DEFAULT 0

int bot_init(bot_t* bot, bot_settings_t* settings) {
  *bot = (bot_t){
      .abort = 1,
      .running = 0,
      .search_mode = SEARCHMODE_INACTIVE,
      .n_threads = BOT_THREAD_COUNT_DEFAULT,
  };
  if (settings) {
    bot->settings = *settings;
  } else {
    bot->settings = (bot_settings_t){
        .debug = 0,
        .Hash = BOT_HASH_SIZE_MB_DEFAULT,
        .Ponder = BOT_CAN_PONDER_DEFAULT,
    };
  }
  tt_init(&bot->transpostion_table, bot->settings.Hash * (1024 * 1024));
  bot->workers = calloc(bot->n_threads, sizeof(worker_t*));
  for (int id = 0; id < bot->n_threads; id++) {
    bot->workers[id] = calloc(1, sizeof(worker_t));
    *bot->workers[id] = (worker_t){.id = id, .bot = bot, .terminated = 1};
  }
  return 0;
}

int bot_load_fen(bot_t* bot, const char* pos_text) {
  chess_state_t* root_position = &bot->root_position;
  return load_position(root_position, pos_text);
}

int bot_load_move(bot_t* bot, const char* movetext) {
  chess_state_t* root_position = &bot->root_position;
  long bytes_to_read = strlen(movetext);
  move_t move;
  long out = read_long_algebraic_notation(movetext, bytes_to_read, root_position, &move);

  if (out == -1) {
    release_position(root_position);
    return -1;
  }
  make_move(root_position, move);
  
  return out;
}

int bot_start(bot_t* bot) {
  clock_gettime(CLOCK_MONOTONIC, &bot->start_time);

  atomic_store(&bot->nodes_searched, 0);
  atomic_store(&bot->depth_searched, 0);
  atomic_store(&bot->duration_ms, 0);
  atomic_store(&bot->abort, 0);
  atomic_store(&bot->running, 1);

  for (int i = 0; i < bot->n_threads; i++) {
    if (pthread_create(&bot->workers[i]->handle, NULL, worker_start,
                       bot->workers[i])) {
      bot_stop(bot);
      return -1;
    }
  }

  return 0;
}

int bot_ponder_hit(bot_t* bot) {
  clock_gettime(CLOCK_MONOTONIC, &bot->start_time);

  bot->search_mode = SEARCHMODE_REGULAR;
  
  atomic_store(&bot->nodes_searched, 0);
  atomic_store(&bot->depth_searched, 0);
  atomic_store(&bot->duration_ms, 0);
  
  return 0;
}

int bot_stop(bot_t* bot) {
  
  atomic_store(&bot->abort, 1);
  return 0;
}

int bot_wait(bot_t* bot) {
  if (!bot_is_running(bot)) return 0;
  for (int i = 0; i < bot->n_threads; i++) {
    pthread_join(bot->workers[i]->handle, NULL);
  }
  return 0;
}

int bot_is_running(bot_t* bot) {
  if (atomic_load(&bot->running)) return 1;
  return 0;
}

int bot_release(bot_t* bot) {
  bot_stop(bot);
  bot_wait(bot);
  for (int i = 0; i < bot->n_threads; i++) {
    free(bot->workers[i]);
  }
  tt_free(&bot->transpostion_table);
  free(bot->workers);
  return 0;
}

// Expanded from src/eval/move_order.c
#include <string.h>

#define FALLTHROUGH __attribute__((fallthrough))

void reset_butterfly_board(int16_t* board) {
  memset(board, 0, sizeof(int16_t) * BUTTERFLY_BOARD_SIZE);
}

void add_killer_move(compact_move_t* killer_moves, move_t move) {
  compact_move_t compressed_move = compress_move(move);
  if (compressed_move == killer_moves[0]) return;
  for (int i = MAX_KILLER_MOVES - 1; i > 0; i--) {
    killer_moves[i] = killer_moves[i - 1];
  }
  killer_moves[0] = compressed_move;
}


void generate_capture_priorities(const chess_state_t* position,
                                 move_list_t* move_list) {
  for (size_t i = 0; i < move_list->move_count; i++) {
    uint16_t prio = PRIORITY_QUIET_MOVE;
    move_t move = move_list->moves[i];
    if (is_promotion(move)) {
      prio = PRIORITY_WINNING_CAPTURE + value_of(piece(position, move.to)) +
             value_of(get_promotes_to(move));
    } else if (is_capture(move)) {
      // SEE reduces the number of nodes search substantially but still
      // increases run time potentially it will be worth re-enabling if
      // additional features cause the eval time to increase and therefor the
      // better branch efficiency will make up for the overhead
      /*int see = static_exchange_evaluation(position, move);
      if (see > 0) {
        prio = PRIORITY_WINNING_CAPTURE;
      } else if (see == 0) {
        prio = PRIORITY_NEUTRAL_CAPTURE;
      } else {
        prio = PRIORITY_LOSING_CAPTURE;
      }*/
      prio = PRIORITY_NEUTRAL_CAPTURE;
      prio += value_of(piece(position, move.to)) -
              value_of(piece(position, move.from));
      move_list->moves[i] = set_priority(move, prio);
    }
  }
}

void generate_quiet_priorities(const chess_state_t* position,
                               move_list_t* move_list) {
  (void)position;
  for (size_t i = 0; i < move_list->move_count; i++) {
    uint16_t prio = PRIORITY_QUIET_MOVE;
    move_t move = move_list->moves[i];
    if (get_butteryfly_board(move_list->bh, move) == 0) {
      prio = 0;
    } else {
      prio = get_butteryfly_board(move_list->hh, move) * 256 /
              get_butteryfly_board(move_list->bh, move);
    }
    move_list->moves[i] = set_priority(move, prio);
  }
}

void init_move_list(const chess_state_t* position, move_list_t* move_list,
                    move_t hash_move, compact_move_t* killer_moves, int16_t* hh,
                    int16_t* bh) {
  (void)position;
  *move_list = (move_list_t){
      .move_count = 0,
      .hash_move = hash_move,
      .killer_moves = killer_moves,
      .hh = hh,
      .bh = bh,
      .state = PRIORITY_PV_MOVE,
  };
}

move_t select_best_move(move_list_t* move_list) {
  size_t selected_idx = 0;
  move_t selected_move;
  int max_priority = get_priority(move_list->moves[0]);
  for (size_t i = 1; i < move_list->move_count; i++) {
    int prio = get_priority(move_list->moves[i]);
    if (prio >= max_priority) {
      max_priority = prio;
      selected_idx = i;
    }
  }
  selected_move = move_list->moves[selected_idx];
  move_list->moves[selected_idx] =
      move_list->moves[--move_list->move_count];
  return selected_move;
}

move_t next_capture(const chess_state_t* position, move_list_t* move_list) {
  move_t selected_move;
  do {
    switch (move_list->state) {
      case PRIORITY_PV_MOVE:
        if (is_pseudo_legal(position, move_list->hash_move)) {
          selected_move = move_list->hash_move;
          move_list->state = PRIORITY_WINNING_CAPTURE;
          break;
        }
        move_list->state = PRIORITY_WINNING_CAPTURE;
        FALLTHROUGH;
      case PRIORITY_WINNING_CAPTURE:
        move_list->move_count = generate_promotions(position, move_list->moves,
                                                    position->friendly_colour);
        generate_capture_priorities(position, move_list);
        move_list->state = PRIORITY_NEUTRAL_CAPTURE;
        FALLTHROUGH;
      case PRIORITY_NEUTRAL_CAPTURE:

        if (move_list->move_count > 0) {
          selected_move = select_best_move(move_list);
          break;
        }
        move_list->state = PRIORITY_LOSING_CAPTURE;
        move_list->move_count = generate_captures(position, move_list->moves,
                                                  position->friendly_colour);
        generate_capture_priorities(position, move_list);
        FALLTHROUGH;
      case PRIORITY_LOSING_CAPTURE:
        if (move_list->move_count > 0) {
          selected_move = select_best_move(move_list);
          break;
        }
        move_list->state = PRIORITY_KILLER_MOVES;
        for (int i = 0; i < MAX_KILLER_MOVES; i++) {
          move_t killer = uncompress_move(move_list->killer_moves[i]);
          if (is_pseudo_legal(position, killer)) {
            move_list->moves[move_list->move_count++] = killer;
          }
        }
        FALLTHROUGH;
        default:
        return null_move;
    }
  } while (!is_legal(position, selected_move));
  return selected_move;
}

move_t next_move(const chess_state_t* position, move_list_t* move_list) {
  move_t selected_move;
  do {
    switch (move_list->state) {
      case PRIORITY_PV_MOVE:
        if (is_pseudo_legal(position, move_list->hash_move)) {
          selected_move = move_list->hash_move;
          move_list->state = PRIORITY_WINNING_CAPTURE;
          break;
        }
        move_list->state = PRIORITY_WINNING_CAPTURE;
        FALLTHROUGH;
      case PRIORITY_WINNING_CAPTURE:
        move_list->move_count = generate_promotions(position, move_list->moves, position->friendly_colour);
        generate_capture_priorities(position, move_list);
        move_list->state = PRIORITY_NEUTRAL_CAPTURE;
        FALLTHROUGH;
      case PRIORITY_NEUTRAL_CAPTURE:
        if (move_list->move_count > 0) {
          selected_move = select_best_move(move_list);
          break;
        }
        move_list->state = PRIORITY_LOSING_CAPTURE;
        move_list->move_count = generate_captures(position, move_list->moves, position->friendly_colour);
        generate_capture_priorities(position, move_list);
        FALLTHROUGH;
      case PRIORITY_LOSING_CAPTURE:
        if (move_list->move_count > 0) {
          selected_move = select_best_move(move_list);
          break;
        }
        move_list->state = PRIORITY_KILLER_MOVES;
        for (int i = 0; i < MAX_KILLER_MOVES; i++) {
          move_t killer = uncompress_move(move_list->killer_moves[i]);
          if (is_pseudo_legal(position, killer)) {
            move_list->moves[move_list->move_count++] = killer;
          }
        }
        FALLTHROUGH;
        case PRIORITY_KILLER_MOVES:
        if (move_list->move_count > 0) {
            selected_move = select_best_move(move_list);
          break;
        }
        move_list->move_count = generate_quiets(position, move_list->moves, position->friendly_colour);
        generate_quiet_priorities(position, move_list);
        move_list->state = PRIORITY_QUIET_MOVE;
        FALLTHROUGH;
      default: {
        if (move_list->move_count == 0) return null_move;
        selected_move = select_best_move(move_list);
      } break;
    }

  } while (!is_legal(position, selected_move));
  return selected_move;
}
